// ===============================
// Smoobu Proxy Edge Function (FULL)
// v4 - FIX: send-message-to-guest payload validation (messageBody empty)
//     - accepts {message}, {messageBody}, {text}, {content}
//     - trims + strips empty HTML-only bodies
//     - optional subject
//     - keeps CORS allowing x-smoobu-key
// ===============================

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const SMOOBU_BASE_URL = "https://login.smoobu.com/api";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type, x-smoobu-key",
  "Access-Control-Allow-Methods": "GET,POST,PUT,PATCH,DELETE,OPTIONS",
};

async function readJsonOrText(response: Response) {
  const t = await response.text();
  if (!t) return null;
  try {
    return JSON.parse(t);
  } catch {
    return { raw: t };
  }
}

function stripHtmlToText(input: string): string {
  // Very small sanitizer: remove tags + decode basic entities we commonly see
  return input
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")
    .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, "")
    .replace(/<[^>]+>/g, " ")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/\s+/g, " ")
    .trim();
}

function coerceMessageBody(body: any): string {
  const candidates = [
    body?.messageBody,
    body?.message,
    body?.text,
    body?.content,
    body?.reply,
    body?.ai_suggestion,
    body?.aiSuggestion,
  ].filter((v) => typeof v === "string");

  const raw = (candidates[0] ?? "").toString();
  const trimmed = raw.trim();

  if (!trimmed) return "";

  // If it's HTML-ish, strip to text to avoid "empty" after tags
  const looksHtml = /<\w+|&nbsp;|<br\s*\/?>/i.test(trimmed);
  const normalized = looksHtml ? stripHtmlToText(trimmed) : trimmed;

  return normalized.trim();
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    const url = new URL(req.url);
    const action = url.searchParams.get("action");
    const verifyQuery = url.searchParams.get("verify");

    const SMOOBU_API_KEY = req.headers.get("x-smoobu-key");
    if (!SMOOBU_API_KEY) {
      return new Response(JSON.stringify({ error: "Missing Smoobu API Key" }), {
        status: 401,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    const smoobuHeaders = {
      "Content-Type": "application/json",
      "Api-Key": SMOOBU_API_KEY,
    };

    // ===============================
    // ACTION: messages
    // ===============================
    if (action === "messages") {
      const bookingId = url.searchParams.get("bookingId");
      if (!bookingId) {
        return new Response(JSON.stringify({ error: "bookingId required" }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }

      const response = await fetch(
        `${SMOOBU_BASE_URL}/reservations/${bookingId}/messages`,
        { headers: smoobuHeaders }
      );

      const data = await readJsonOrText(response);
      return new Response(JSON.stringify(data), {
        status: response.status,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // ===============================
    // ACTION: send-message  (send to guest)
    // Endpoint: POST /reservations/{id}/messages/send-message-to-guest
    // Body: { messageBody: string, subject?: string }
    // ===============================
    if (action === "send-message") {
      const body = await req.json();
      const bookingId = body?.bookingId ?? body?.reservationId ?? body?.id;
      const verify = body?.verify || verifyQuery === "1";

      const messageBody = coerceMessageBody(body);
      const subject =
        typeof body?.subject === "string" ? body.subject.trim() : undefined;

      if (!bookingId || typeof bookingId !== "string" && typeof bookingId !== "number") {
        return new Response(JSON.stringify({ error: "bookingId required" }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }

      if (!messageBody) {
        return new Response(
          JSON.stringify({
            error: "messageBody required (provide body.message or body.messageBody)",
            hint: "Your message was empty after trimming/HTML stripping.",
          }),
          {
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
          }
        );
      }

      const endpoint = `${SMOOBU_BASE_URL}/reservations/${bookingId}/messages/send-message-to-guest`;

      const sendResponse = await fetch(endpoint, {
        method: "POST",
        headers: smoobuHeaders,
        body: JSON.stringify({
          messageBody,
          ...(subject ? { subject } : {}),
        }),
      });

      const sendData = await readJsonOrText(sendResponse);

      // Optional: verify by re-fetching messages and searching for the sent text
      let verified: boolean | null = null;
      let verifySample: any = null;

      if (verify && sendResponse.ok) {
        try {
          const verifyResponse = await fetch(
            `${SMOOBU_BASE_URL}/reservations/${bookingId}/messages`,
            { headers: smoobuHeaders }
          );
          const verifyData = await readJsonOrText(verifyResponse);
          const msgs = (verifyData as any)?.messages;

          if (Array.isArray(msgs)) {
            const needle = messageBody.toLowerCase();
            verified = msgs.some((m: any) =>
              String(m?.message || "")
                .toLowerCase()
                .includes(needle)
            );
            verifySample = msgs.slice(0, 3);
          } else {
            verified = false;
          }
        } catch {
          verified = false;
        }
      }

      return new Response(
        JSON.stringify({
          ok: sendResponse.ok,
          status: sendResponse.status,
          result: sendData,
          verified,
          verify_sample: verifySample,
        }),
        {
          status: sendResponse.ok ? 200 : sendResponse.status,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    // ===============================
    // IMPORTANT:
    // Keep your existing actions (rates, apartments, update-rates, ticketmaster, etc.)
    // This file focuses on the send-message fix; if you had additional actions in your
    // current deployment, merge them below unchanged.
    // ===============================

    return new Response(JSON.stringify({ error: "Invalid action" }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (err) {
    return new Response(JSON.stringify({ error: (err as Error).message }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
