<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>PilotStay - Host Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#09090b;color:#fafafa;min-height:100vh}
.loading-screen{position:fixed;inset:0;background:#09090b;display:flex;align-items:center;justify-content:center;z-index:9999;flex-direction:column;gap:16px}
.spinner{width:48px;height:48px;border:3px solid #27272a;border-top-color:#f97316;border-radius:50%;animation:spin .8s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
.pulse{animation:pulse 2s infinite}
@keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}

/* Tutorial - Interactive Spotlight */
#tutorial-overlay{position:fixed;inset:0;z-index:5000}
#tutorial-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0);z-index:5001;transition:background .3s}
#tutorial-backdrop.active{background:rgba(0,0,0,.8)}
#tutorial-spotlight{position:absolute;z-index:5002;border-radius:12px;box-shadow:0 0 0 9999px rgba(0,0,0,.85), 0 0 40px rgba(249,115,22,.6);transition:all .4s ease;pointer-events:none}
#tutorial-tooltip{position:fixed;z-index:5003;background:linear-gradient(145deg,#1a1a1f,#131316);border:2px solid #f97316;border-radius:16px;padding:28px;width:400px;max-width:90vw;animation:tutorialFadeIn .4s ease;box-shadow:0 20px 60px rgba(0,0,0,.5)}
@keyframes tutorialFadeIn{from{opacity:0;transform:scale(.95) translateY(10px)}to{opacity:1;transform:scale(1) translateY(0)}}
@keyframes tutorialPulse{0%,100%{box-shadow:0 0 0 9999px rgba(0,0,0,.85), 0 0 40px rgba(249,115,22,.6)}50%{box-shadow:0 0 0 9999px rgba(0,0,0,.85), 0 0 60px rgba(249,115,22,.8)}}
#tutorial-spotlight.pulse{animation:tutorialPulse 2s infinite}
#tutorial-arrow{position:absolute;width:0;height:0;border:12px solid transparent}
#tutorial-arrow.left{right:100%;top:30px;border-right-color:#f97316}
#tutorial-arrow.right{left:100%;top:30px;border-left-color:#f97316}
#tutorial-arrow.top{bottom:100%;left:30px;border-bottom-color:#f97316}
#tutorial-arrow.bottom{top:100%;left:30px;border-top-color:#f97316}
#tutorial-arrow.hidden{display:none}
.tutorial-header{display:flex;align-items:center;gap:12px;margin-bottom:16px}
.tutorial-icon{font-size:36px;line-height:1}
.tutorial-step-label{font-size:11px;color:#f97316;font-weight:600;text-transform:uppercase;letter-spacing:1px}
.tutorial-title{font-size:20px;font-weight:700;margin-bottom:10px;color:#fafafa}
.tutorial-desc{color:#a1a1aa;font-size:14px;line-height:1.7;margin-bottom:20px}
.tutorial-progress{display:flex;gap:6px;margin-bottom:20px;justify-content:center}
.tutorial-dot{width:10px;height:10px;border-radius:50%;background:#27272a;transition:all .3s}
.tutorial-dot.done{background:#22c55e}
.tutorial-dot.active{background:#f97316;transform:scale(1.4);box-shadow:0 0 10px rgba(249,115,22,.5)}
.tutorial-actions{display:flex;gap:12px;align-items:center}
.tutorial-skip{background:none;border:none;color:#71717a;font-size:13px;cursor:pointer;padding:8px 16px;transition:color .2s}
.tutorial-skip:hover{color:#fafafa}
.tutorial-next{flex:1;padding:14px 24px;background:linear-gradient(135deg,#f97316,#fb923c);border:none;border-radius:10px;color:#fff;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s}
.tutorial-next:hover{transform:scale(1.02);box-shadow:0 4px 20px rgba(249,115,22,.4)}
.tutorial-highlight{position:relative;z-index:5002}

/* Sidebar */
.sidebar{width:260px;background:#131316;border-right:1px solid #27272a;position:fixed;height:100vh;display:flex;flex-direction:column;z-index:100}
.sidebar-header{padding:20px;border-bottom:1px solid #27272a;display:flex;align-items:center;gap:12px}
.sidebar-logo{width:44px;height:44px;background:linear-gradient(135deg,#f97316,#fb923c);border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:22px}
.sidebar-title{font-weight:700;font-size:18px}
.sidebar-sub{font-size:11px;color:#f97316}
.nav{flex:1;padding:16px;overflow-y:auto}
.nav-section{font-size:10px;color:#52525b;text-transform:uppercase;letter-spacing:1px;padding:12px 14px 8px}
.nav-item{display:flex;align-items:center;gap:12px;padding:12px 14px;border-radius:10px;cursor:pointer;color:#a1a1aa;margin-bottom:4px;transition:all .2s;font-size:13px;position:relative}
.nav-item:hover{background:#1f1f23;color:#fafafa}
.nav-item.active{background:#f9731620;color:#f97316}
.nav-icon{font-size:18px;width:24px;text-align:center}
.nav-badge{position:absolute;right:12px;min-width:20px;height:20px;background:#ef4444;border-radius:10px;font-size:10px;color:#fff;display:flex;align-items:center;justify-content:center}
.user-section{padding:16px;border-top:1px solid #27272a}
.user-card{display:flex;align-items:center;gap:12px;padding:12px;background:#18181b;border-radius:12px;margin-bottom:12px}
.user-avatar{width:40px;height:40px;background:linear-gradient(135deg,#f97316,#fb923c);border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:16px}
.user-name{font-size:14px;font-weight:600}
.user-plan{font-size:11px;color:#a1a1aa}
.logout-btn{width:100%;padding:10px;background:#27272a;border:none;border-radius:8px;color:#a1a1aa;font-size:12px;cursor:pointer}
.logout-btn:hover{background:#3f3f46;color:#fafafa}

/* Main */
.main{margin-left:260px;min-height:100vh}
.header{padding:24px 32px;border-bottom:1px solid #27272a;display:flex;justify-content:space-between;align-items:center;background:#09090b;position:sticky;top:0;z-index:50}
.header-title{font-size:24px;font-weight:700}
.header-subtitle{color:#71717a;font-size:13px;margin-top:4px}
.content{padding:32px}
.chat-layout{display:flex !important;flex-direction:row !important;flex-wrap:nowrap !important;gap:16px !important;height:700px !important;min-height:600px !important;width:100% !important}
.chat-layout > div:first-child{width:320px !important;min-width:320px !important;flex-shrink:0 !important}
.chat-layout > div:last-child{flex:1 1 auto !important;min-width:0 !important}

/* Cards */
.card{background:#131316;border:1px solid #27272a;border-radius:14px;padding:20px;margin-bottom:16px;transition:all .2s}
.card:hover{border-color:#3f3f46}
.card-title{font-size:14px;font-weight:600;margin-bottom:16px;display:flex;align-items:center;gap:10px}
.card-ai{background:linear-gradient(135deg,#131316,#1a1a2e);border-color:#8b5cf650}
.property-card{display:flex;flex-direction:column;min-height:240px}
.property-card:hover{border-color:#f97316;box-shadow:0 4px 20px rgba(249,115,22,.1)}

/* Stats */
.stats-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:16px;margin-bottom:24px}
.stat-card{background:#131316;border:1px solid #27272a;border-radius:14px;padding:24px;text-align:center}
.stat-icon{font-size:28px;margin-bottom:12px}
.stat-value{font-size:32px;font-weight:700}
.stat-label{font-size:12px;color:#71717a;margin-top:6px}
.stat-change{font-size:11px;margin-top:8px;padding:4px 8px;border-radius:20px;display:inline-block}
.stat-change.up{background:#22c55e20;color:#22c55e}
.stat-change.down{background:#ef444420;color:#ef4444}

/* Grids */
.grid-2{display:grid;grid-template-columns:repeat(2,1fr);gap:20px}
.grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:16px}

/* Buttons */
.btn{padding:12px 20px;border:none;border-radius:10px;font-size:13px;font-weight:600;cursor:pointer;display:inline-flex;align-items:center;gap:8px;transition:all .2s}
.btn:hover{transform:scale(1.02)}
.btn-primary{background:linear-gradient(135deg,#f97316,#fb923c);color:#fff}
.btn-success{background:linear-gradient(135deg,#22c55e,#16a34a);color:#fff}
.btn-secondary{background:#27272a;color:#fafafa;border:1px solid #3f3f46}
.btn-ai{background:linear-gradient(135deg,#8b5cf6,#a78bfa);color:#fff}
.btn-sm{padding:8px 14px;font-size:12px}

/* Inputs */
.input{width:100%;padding:14px 16px;background:#18181b;border:1px solid #27272a;border-radius:10px;color:#fafafa;font-size:14px;transition:all .2s}
.input:focus{outline:none;border-color:#f97316}
.input::placeholder{color:#52525b}
.label{display:block;font-size:12px;color:#a1a1aa;margin-bottom:8px}
.select{width:100%;padding:14px 16px;background:#18181b;border:1px solid #27272a;border-radius:10px;color:#fafafa;font-size:14px}

/* Tags */
.tag{padding:4px 12px;border-radius:20px;font-size:11px;font-weight:600}
.tag-green{background:#22c55e20;color:#22c55e}
.tag-orange{background:#f9731620;color:#f97316}
.tag-blue{background:#3b82f620;color:#3b82f6}
.tag-purple{background:#8b5cf620;color:#8b5cf6}
.tag-red{background:#ef444420;color:#ef4444}

/* Lists */
.list-item{display:flex;align-items:center;gap:16px;padding:16px;background:#18181b;border-radius:12px;margin-bottom:10px;transition:all .2s}
.list-item:hover{background:#1f1f23}
.list-icon{font-size:28px}
.list-info{flex:1}
.list-title{font-weight:600;font-size:14px}
.list-subtitle{font-size:12px;color:#71717a;margin-top:2px}

/* Empty State */
.empty-state{text-align:center;padding:60px 20px;color:#71717a}
.empty-icon{font-size:56px;margin-bottom:16px}
.empty-title{font-size:16px;font-weight:600;color:#fafafa;margin-bottom:8px}
.empty-desc{font-size:13px;margin-bottom:20px}

/* Modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;z-index:1000;padding:20px}
.modal{background:#131316;border:1px solid #27272a;border-radius:16px;padding:28px;width:100%;max-width:500px;max-height:90vh;overflow-y:auto}
.modal-title{font-size:18px;font-weight:700;margin-bottom:20px;display:flex;align-items:center;gap:10px}

/* Table */
.table{width:100%;border-collapse:collapse}
.table th,.table td{padding:14px 16px;text-align:left;border-bottom:1px solid #27272a}
.table th{font-size:11px;color:#71717a;text-transform:uppercase}
.table tr:hover td{background:#18181b}

/* Chat */
.chat-container{display:grid;grid-template-columns:280px 1fr;gap:20px;height:calc(100vh - 200px)}
.chat-list{background:#131316;border:1px solid #27272a;border-radius:14px;overflow:hidden;display:flex;flex-direction:column}
.chat-list-header{padding:16px;border-bottom:1px solid #27272a;font-weight:600}
.chat-list-items{flex:1;overflow-y:auto}
.chat-item{display:flex;align-items:center;gap:12px;padding:14px 16px;cursor:pointer;border-bottom:1px solid #27272a20;transition:all .2s}
.chat-item:hover,.chat-item.active{background:#1f1f23}
.chat-item.active{border-left:3px solid #f97316}
.chat-avatar{width:40px;height:40px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px}
.chat-preview{flex:1;min-width:0}
.chat-name{font-weight:600;font-size:13px;margin-bottom:2px}
.chat-last{font-size:11px;color:#71717a;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.chat-time{font-size:10px;color:#52525b}
.chat-unread{min-width:20px;height:20px;background:#ef4444;border-radius:10px;font-size:10px;color:#fff;display:flex;align-items:center;justify-content:center}
.chat-window{background:#131316;border:1px solid #27272a;border-radius:14px;display:flex;flex-direction:column;max-height:calc(100vh - 200px)}
.chat-header{padding:16px 20px;border-bottom:1px solid #27272a;display:flex;align-items:center;gap:12px;flex-shrink:0}
.chat-messages{flex:1;overflow-y:auto;padding:20px;display:flex;flex-direction:column;gap:12px;min-height:200px;max-height:450px}
.message{max-width:75%;display:flex;flex-direction:column}
.message.sent{align-self:flex-end;align-items:flex-end}
.message.received{align-self:flex-start;align-items:flex-start}
.message-sender{font-size:10px;font-weight:600;margin-bottom:4px;padding:0 4px}
.message.sent .message-sender{color:#f97316}
.message.received .message-sender{color:#22c55e}
.message-bubble{padding:12px 16px;border-radius:16px;font-size:14px;line-height:1.5;word-wrap:break-word}
.message.sent .message-bubble{background:linear-gradient(135deg,#f97316,#fb923c);color:#fff;border-bottom-right-radius:4px}
.message.received .message-bubble{background:#27272a;color:#fafafa;border-bottom-left-radius:4px}
.message-ai .message-bubble{background:linear-gradient(135deg,#8b5cf6,#a78bfa);color:#fff}
.message-time{font-size:10px;color:#52525b;margin-top:4px;padding:0 4px}
.chat-input{padding:16px;border-top:1px solid #27272a;display:flex;gap:12px;flex-shrink:0}
.chat-input input{flex:1}
.smart-replies{padding:12px 16px;border-top:1px solid #27272a;background:#18181b;flex-shrink:0;max-height:120px;overflow-y:auto}
.smart-replies-title{font-size:11px;color:#8b5cf6;margin-bottom:8px;display:flex;align-items:center;gap:6px}
.smart-reply-btn{padding:8px 14px;background:#27272a;border:1px solid #3f3f46;border-radius:20px;color:#fafafa;font-size:12px;cursor:pointer;margin-right:8px;margin-bottom:8px;transition:all .2s}
.smart-reply-btn:hover{background:#8b5cf620;border-color:#8b5cf6}

/* Reviews */
.review-card{background:#18181b;border-radius:12px;padding:20px;margin-bottom:16px}
.review-header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
.review-avatar{width:44px;height:44px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:16px;background:linear-gradient(135deg,#3b82f6,#60a5fa)}
.review-info{flex:1}
.review-name{font-weight:600;font-size:14px}
.review-meta{font-size:11px;color:#71717a;margin-top:2px}
.review-stars{color:#fbbf24}
.review-text{font-size:14px;line-height:1.6;margin-bottom:16px}
.review-reply{background:#131316;border-radius:10px;padding:14px;margin-top:12px}
.review-reply-label{font-size:11px;color:#71717a;margin-bottom:6px}
.ai-suggestion{background:linear-gradient(135deg,#8b5cf620,#8b5cf610);border:1px solid #8b5cf640;border-radius:12px;padding:16px;margin-top:12px}
.ai-suggestion-header{font-size:12px;color:#8b5cf6;margin-bottom:8px;display:flex;align-items:center;gap:6px}
.ai-suggestion-text{font-size:13px;line-height:1.6;margin-bottom:12px}

/* Pricing */
.pricing-card{background:#18181b;border-radius:12px;padding:20px}
.pricing-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
.pricing-property{font-weight:600;font-size:16px}
.pricing-current{font-size:24px;font-weight:700}
.pricing-suggestion{display:flex;align-items:center;gap:12px;padding:16px;background:linear-gradient(135deg,#22c55e10,#22c55e05);border:1px solid #22c55e40;border-radius:10px;margin-top:12px}
.pricing-arrow{font-size:24px}
.pricing-new{font-size:28px;font-weight:700;color:#22c55e}
.pricing-reason{font-size:12px;color:#a1a1aa;margin-top:4px}
.pricing-factors{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
.pricing-calendar{display:grid;grid-template-columns:repeat(7,1fr);gap:4px;margin-top:16px}
.cal-header{font-size:10px;color:#71717a;text-align:center;padding:8px}
.cal-day{aspect-ratio:1;border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:12px;cursor:pointer;transition:all .2s}
.cal-day:hover{background:#27272a}
.cal-day.low{background:#22c55e20;color:#22c55e}
.cal-day.medium{background:#f9731620;color:#f97316}
.cal-day.high{background:#ef444420;color:#ef4444}
.cal-day .cal-price{font-size:9px;margin-top:2px}

/* Toggle */
.toggle{width:48px;height:26px;border-radius:13px;background:#27272a;border:none;cursor:pointer;position:relative;transition:all .2s}
.toggle.active{background:#22c55e}
.toggle-knob{width:20px;height:20px;border-radius:50%;background:#fff;position:absolute;top:3px;left:3px;transition:all .2s}
.toggle.active .toggle-knob{left:25px}

/* Responsive */
@media(max-width:1200px){.stats-grid{grid-template-columns:repeat(2,1fr)}.chat-container{grid-template-columns:1fr}}
@media(max-width:900px){.grid-2,.grid-3{grid-template-columns:1fr}}
@media(max-width:768px){.sidebar{display:none}.main{margin-left:0}}
</style>
</head>
<body>

<!-- Loading -->
<div class="loading-screen" id="loading">
  <div class="spinner"></div>
  <div style="color:#71717a">PilotStay wird geladen...</div>
</div>

<!-- Tutorial Spotlight Overlay -->
<div id="tutorial-overlay" style="display:none">
  <div id="tutorial-backdrop"></div>
  <div id="tutorial-spotlight"></div>
  <div id="tutorial-tooltip">
    <div id="tutorial-arrow"></div>
    <div class="tutorial-header">
      <span id="tutorial-step-icon" class="tutorial-icon">üëã</span>
      <span id="tutorial-step-label" class="tutorial-step-label">Schritt 1 von 10</span>
    </div>
    <div id="tutorial-step-title" class="tutorial-title">Willkommen!</div>
    <div id="tutorial-step-desc" class="tutorial-desc">Beschreibung</div>
    <div id="tutorial-progress" class="tutorial-progress"></div>
    <div class="tutorial-actions">
      <button id="tutorial-skip" class="tutorial-skip">√úberspringen</button>
      <button id="tutorial-next" class="tutorial-next">Weiter ‚Üí</button>
    </div>
  </div>
</div>

<!-- App -->
<div id="app" style="display:none">
  
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-logo">üè†</div>
      <div>
        <div class="sidebar-title">PilotStay</div>
        <div class="sidebar-sub">Host Dashboard</div>
      </div>
    </div>
    
    <nav class="nav">
      <div class="nav-section">Hauptmen√º</div>
      <div class="nav-item active" data-page="dashboard">
        <span class="nav-icon">üìä</span>Dashboard
      </div>
      <div class="nav-item" data-page="bookings">
        <span class="nav-icon">üìÖ</span>Buchungen
      </div>
      <div class="nav-item" data-page="properties">
        <span class="nav-icon">üè†</span>Objekte
      </div>
      <!-- HIDDEN: Partner module temporarily disabled
      <div class="nav-item" data-page="partners">
        <span class="nav-icon">ü§ù</span>Partner
      </div>
      -->
      
      <div class="nav-section">KI-Tools</div>
      <div class="nav-item" data-page="messages">
        <span class="nav-icon">üí¨</span>Nachrichten
        <span class="nav-badge" id="msg-badge">3</span>
      </div>
      <div class="nav-item" data-page="reviews">
        <span class="nav-icon">‚≠ê</span>Bewertungen
        <span class="nav-badge" style="background:#8b5cf6">2</span>
      </div>
      <div class="nav-item" data-page="pricing">
        <span class="nav-icon">üí∞</span>Preisoptimierung
      </div>
      
      <div class="nav-section">System</div>
      <div class="nav-item" data-page="automation">
        <span class="nav-icon">ü§ñ</span>Automatisierung
      </div>
      <div class="nav-item" data-page="settings">
        <span class="nav-icon">‚öôÔ∏è</span>Einstellungen
      </div>
    </nav>
    
    <div class="user-section">
      <div class="user-card">
        <div class="user-avatar" id="user-avatar">?</div>
        <div>
          <div class="user-name" id="user-name">Laden...</div>
          <div class="user-plan">‚≠ê Starter Plan</div>
        </div>
      </div>
      <button class="logout-btn" id="logout-btn">üö™ Abmelden</button>
    </div>
  </aside>
  
  <!-- Main -->
  <main class="main">
    <div class="header">
      <div>
        <div class="header-title" id="page-title">Dashboard</div>
        <div class="header-subtitle" id="page-subtitle"></div>
      </div>
      <div style="display:flex;align-items:center;gap:16px">
        <!-- Notification Button -->
        <button onclick="showNotifications()" style="position:relative;background:none;border:none;cursor:pointer;padding:8px">
          <span style="font-size:20px">üîî</span>
          <span id="notification-badge" style="display:none;position:absolute;top:2px;right:2px;background:#ef4444;color:white;font-size:10px;font-weight:700;min-width:16px;height:16px;border-radius:8px;display:flex;align-items:center;justify-content:center">0</span>
        </button>
        <div id="header-actions"></div>
      </div>
    </div>
    <div class="content" id="content"></div>
  </main>
</div>

<!-- Modal -->
<div class="modal-overlay" id="modal" style="display:none">
  <div class="modal" id="modal-content"></div>
</div>

<script>
// =====================
// SUPABASE
// =====================
const db = window.supabase.createClient(
  'https://uamlcodalgibboftvhqp.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVhbWxjb2RhbGdpYmJvZnR2aHFwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgzMTUyNDIsImV4cCI6MjA4Mzg5MTI0Mn0.t7OwT2MjL1CVdQTQAOaA1HwowFpaZsVZcqjTFHuTL1w'
);

// =====================
// STATE
// =====================
let user, profile, currentPage = 'dashboard';
let properties = [], bookings = [];

// Smoobu Integration
const SMOOBU_PROXY_URL = 'https://uamlcodalgibboftvhqp.supabase.co/functions/v1/smoobu-proxy';

let smoobuConfig = {
  apiKey: localStorage.getItem('smoobu_api_key') || '',
  connected: localStorage.getItem('smoobu_connected') === 'true',
  lastSync: localStorage.getItem('smoobu_last_sync') || null,
  syncInterval: null,
  smoobuUser: null,
  smoobuApartments: []
};

// AI Proxy URL (your Supabase Edge Function - keeps OpenAI key secret)
const AI_PROXY_URL = 'https://uamlcodalgibboftvhqp.supabase.co/functions/v1/ai-proxy';

// Automation Settings - persisted in localStorage and Supabase
// Modes: 'off' | 'manual' | 'auto' | 'hybrid'
let automationSettings = {
  // Smart Replies for Guest Messages
  smartReplies: localStorage.getItem('auto_smart_replies') !== 'false',
  smartRepliesMode: localStorage.getItem('smart_replies_mode') || 'manual', // manual, auto, hybrid
  
  // Review Replies
  reviewReplies: localStorage.getItem('auto_review_replies') !== 'false',
  reviewRepliesMode: localStorage.getItem('review_replies_mode') || 'manual',
  
  // Auto Pricing
  autoPricing: localStorage.getItem('auto_pricing') !== 'false',
  autoPricingMode: localStorage.getItem('auto_pricing_mode') || 'manual',
  
  // Auto Jobs (Cleaning etc)
  autoJobs: localStorage.getItem('auto_jobs') === 'true',
  autoJobsMode: localStorage.getItem('auto_jobs_mode') || 'manual',
  
  // AI Learning & Personalization
  aiLearning: localStorage.getItem('ai_learning') !== 'false',
  aiTone: localStorage.getItem('ai_tone') || 'friendly', // formal, friendly, casual
  aiLanguage: localStorage.getItem('ai_language') || 'de'
};

// AI Context - Learned patterns and preferences per property
let aiContext = {
  properties: {}, // propertyId -> { wifi, parking, checkin, checkout, houseRules, customInfo }
  savedReplies: [], // Successful replies that can be reused
  feedbackHistory: [], // { messageId, response, rating, timestamp }
  commonQuestions: {} // question pattern -> best answer
};

// Server-side notifications (from cron job)
let notifications = [];
let unreadNotificationCount = 0;

// Auto-reply categories for hybrid mode
const autoReplyCategories = {
  // Simple questions - can be auto-answered
  simple: [
    'wifi', 'wlan', 'internet', 'passwort', 'password',
    'parkplatz', 'parken', 'parking', 'garage',
    'check-in', 'checkin', 'check-out', 'checkout', 'zeit', 'uhrzeit', 'time',
    'adresse', 'address', 'anfahrt', 'weg', 'finden',
    'schl√ºssel', 'key', 'code', 'zugang',
    'm√ºll', 'trash', 'garbage', 'recycling',
    'heizung', 'heating', 'klimaanlage', 'ac', 'air conditioning',
    'handt√ºcher', 'towels', 'bettw√§sche', 'bedding',
    'danke', 'thanks', 'thank you', 'super', 'toll', 'great'
  ],
  // Complex questions - need manual approval
  complex: [
    'problem', 'kaputt', 'broken', 'funktioniert nicht', 'not working',
    'beschwerde', 'complaint', 'unzufrieden', 'unhappy',
    'stornieren', 'cancel', 'stornierung', 'cancellation',
    'erstattung', 'refund', 'geld zur√ºck', 'money back',
    'verl√§ngern', 'extend', 'l√§nger', 'longer', 'weitere nacht',
    'fr√ºher', 'earlier', 'sp√§ter', 'later', '√§ndern', 'change',
    'notfall', 'emergency', 'dringend', 'urgent',
    'unfall', 'accident', 'verletzt', 'injured',
    'polizei', 'police', 'krankenhaus', 'hospital'
  ]
};

// Check if a message is simple (for hybrid mode)
function isSimpleQuestion(message) {
  const text = message.toLowerCase();
  
  // Check if contains complex keywords
  for (const keyword of autoReplyCategories.complex) {
    if (text.includes(keyword)) return false;
  }
  
  // Check if contains simple keywords
  for (const keyword of autoReplyCategories.simple) {
    if (text.includes(keyword)) return true;
  }
  
  // Default to complex (needs manual approval) for safety
  return false;
}

// Demo data for AI features
// Chats - loaded from Smoobu messages API
let chats = [];
let activeChat = null;

// Reviews - loaded from Smoobu/Airbnb API
let reviews = [];

let pricingData = {
  enabled: true,
  strategy: 'balanced',
  properties: [], // Will be populated from Smoobu sync or local properties
  dailyPrices: {}, // propertyId -> [{date, basePrice, finalPrice, factors, events}]
  events: [], // Cached events from Ticketmaster
  lastEventFetch: null
};

// German holidays 2025/2026
const germanHolidays = [
  { date: '2025-01-01', name: 'Neujahr', boost: 0.20 },
  { date: '2025-04-18', name: 'Karfreitag', boost: 0.15 },
  { date: '2025-04-20', name: 'Ostersonntag', boost: 0.25 },
  { date: '2025-04-21', name: 'Ostermontag', boost: 0.25 },
  { date: '2025-05-01', name: 'Tag der Arbeit', boost: 0.15 },
  { date: '2025-05-29', name: 'Christi Himmelfahrt', boost: 0.20 },
  { date: '2025-06-08', name: 'Pfingstsonntag', boost: 0.20 },
  { date: '2025-06-09', name: 'Pfingstmontag', boost: 0.20 },
  { date: '2025-10-03', name: 'Tag der Deutschen Einheit', boost: 0.15 },
  { date: '2025-12-24', name: 'Heiligabend', boost: 0.30 },
  { date: '2025-12-25', name: '1. Weihnachtstag', boost: 0.35 },
  { date: '2025-12-26', name: '2. Weihnachtstag', boost: 0.35 },
  { date: '2025-12-31', name: 'Silvester', boost: 0.50 },
  { date: '2026-01-01', name: 'Neujahr', boost: 0.20 },
  { date: '2026-04-03', name: 'Karfreitag', boost: 0.15 },
  { date: '2026-04-05', name: 'Ostersonntag', boost: 0.25 },
  { date: '2026-04-06', name: 'Ostermontag', boost: 0.25 },
  { date: '2026-05-01', name: 'Tag der Arbeit', boost: 0.15 },
  { date: '2026-05-14', name: 'Christi Himmelfahrt', boost: 0.20 },
  { date: '2026-05-24', name: 'Pfingstsonntag', boost: 0.20 },
  { date: '2026-05-25', name: 'Pfingstmontag', boost: 0.20 },
  { date: '2026-10-03', name: 'Tag der Deutschen Einheit', boost: 0.15 },
  { date: '2026-12-24', name: 'Heiligabend', boost: 0.30 },
  { date: '2026-12-25', name: '1. Weihnachtstag', boost: 0.35 },
  { date: '2026-12-26', name: '2. Weihnachtstag', boost: 0.35 },
  { date: '2026-12-31', name: 'Silvester', boost: 0.50 },
];

// Ticketmaster API (free tier: 5000 calls/day)
const TICKETMASTER_API_KEY = 'pLOeuGq2JL05uEGrZG7DuGWu6sh2OnMz'; // Public demo key

// Tutorial - Interactive Spotlight Tour
const tutorialSteps = [
  {
    id: 'welcome',
    icon: 'üëã',
    title: 'Willkommen bei PilotStay!',
    desc: 'Sch√∂n, dass du dabei bist! Ich zeige dir in 2 Minuten alle wichtigen Funktionen deines Dashboards.',
    target: null, // No spotlight for welcome
    position: 'center',
    button: "Los geht's! üöÄ"
  },
  {
    id: 'sidebar',
    icon: 'üìç',
    title: 'Navigation',
    desc: 'Hier findest du alle Module. Klicke einfach auf einen Men√ºpunkt um zwischen den Bereichen zu wechseln.',
    target: '.sidebar',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'dashboard',
    icon: 'üìä',
    title: 'Dashboard',
    desc: 'Deine Zentrale! Hier siehst du auf einen Blick: Umsatz, Buchungen, neue Nachrichten und deinen KI-Score.',
    target: '[data-page="dashboard"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'bookings',
    icon: 'üìÖ',
    title: 'Buchungen',
    desc: 'Alle deine Reservierungen an einem Ort. Du kannst Buchungen manuell hinzuf√ºgen, bearbeiten oder l√∂schen.',
    target: '[data-page="bookings"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'properties',
    icon: 'üè†',
    title: 'Objekte',
    desc: 'Verwalte deine Ferienwohnungen. F√ºge neue hinzu oder verbinde sie mit Smoobu f√ºr automatischen Import.',
    target: '[data-page="properties"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'messages',
    icon: 'üí¨',
    title: 'Nachrichten',
    desc: 'Kommuniziere mit deinen G√§sten. Die KI schl√§gt dir automatisch passende Antworten vor - mit einem Klick absenden!',
    target: '[data-page="messages"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'reviews',
    icon: '‚≠ê',
    title: 'Bewertungen',
    desc: 'Alle G√§stebewertungen im √úberblick. Die KI generiert personalisierte Antworten, die du nur noch best√§tigen musst.',
    target: '[data-page="reviews"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'pricing',
    icon: 'üí∞',
    title: 'Preisoptimierung',
    desc: 'Hier wird es spannend! Die KI analysiert Nachfrage, Events und Wettbewerb und schl√§gt optimale Preise vor.',
    target: '[data-page="pricing"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'automation',
    icon: 'ü§ñ',
    title: 'Automatisierung',
    desc: 'Das Herzst√ºck! Verbinde Smoobu, aktiviere KI-Features und lass PilotStay f√ºr dich arbeiten.',
    target: '[data-page="automation"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'settings',
    icon: '‚öôÔ∏è',
    title: 'Einstellungen',
    desc: 'Verwalte dein Profil, √§ndere dein Passwort und passe deine Benachrichtigungen an.',
    target: '[data-page="settings"]',
    position: 'right',
    button: 'Weiter ‚Üí'
  },
  {
    id: 'complete',
    icon: 'üéâ',
    title: 'Fertig!',
    desc: 'Du kennst jetzt alle Funktionen! Tipp: Starte mit der Smoobu-Verbindung unter "Automatisierung" um deine Daten zu importieren.',
    target: null,
    position: 'center',
    button: 'Dashboard starten! ‚ú®'
  }
];
let tutorialCurrentStep = 0;

// =====================
// INIT
// =====================
async function init() {
  try {
    // Check if running locally (file://)
    if (window.location.protocol === 'file:') {
      showLocalFileError();
      return;
    }
    
    const {data:{session}, error} = await db.auth.getSession();
    
    if (error) {
      console.error('Auth error:', error);
      showAuthError(error.message);
      return;
    }
    
    if (!session) {
      // No session - redirect to login
      window.location.href = 'auth.html';
      return;
    }
    
    user = session.user;
    const {data:p} = await db.from('profiles').select('*').eq('id', user.id).single();
    profile = p;
    
    if (profile?.role !== 'host' && profile?.role !== 'admin') {
      window.location.href = 'partner-dashboard.html';
      return;
    }
    
    await loadData();
    await loadAutomationSettings();
    loadPricingStrategy();
    
    document.getElementById('loading').style.display = 'none';
    document.getElementById('app').style.display = 'block';
    
    renderUser();
    checkSmoobuConnection();
    renderPage();
    bindEvents();
    
    // Show tutorial on first login - but NOT if Smoobu is already connected
    // Check both localStorage and Supabase profile for tutorial completion
    const tutorialDoneLocal = localStorage.getItem('ps_tut_done');
    const tutorialDoneSupabase = profile?.tutorial_completed;
    const tutorialDone = tutorialDoneLocal || tutorialDoneSupabase;
    const smoobuAlreadyConnected = smoobuConfig.connected;
    
    if (!tutorialDone && !smoobuAlreadyConnected) {
      setTimeout(() => startTutorial(), 500);
    } else if (!tutorialDone && smoobuAlreadyConnected) {
      // Mark tutorial as done if Smoobu is already connected
      localStorage.setItem('ps_tut_done', 'true');
      saveTutorialCompleted();
    }
    
  } catch (err) {
    console.error('Init error:', err);
    showAuthError(err.message);
  }
}

function showLocalFileError() {
  document.getElementById('loading').innerHTML = `
    <div style="text-align:center;max-width:400px;padding:20px">
      <div style="font-size:48px;margin-bottom:16px">‚ö†Ô∏è</div>
      <div style="font-size:18px;font-weight:700;margin-bottom:12px">Lokale Datei erkannt</div>
      <div style="color:#a1a1aa;font-size:14px;line-height:1.6;margin-bottom:24px">
        Das Dashboard kann nicht als lokale Datei ge√∂ffnet werden.<br><br>
        Bitte √∂ffne es √ºber deine Vercel-URL:
      </div>
      <a href="https://pilotstay-appp.vercel.app" class="btn btn-primary" style="text-decoration:none">
        üåê Zu PilotStay √∂ffnen
      </a>
      <div style="margin-top:24px;padding-top:24px;border-top:1px solid #27272a">
        <div style="font-size:12px;color:#71717a">Oder lade die Datei auf GitHub hoch und deploye √ºber Vercel</div>
      </div>
    </div>
  `;
}

function showAuthError(message) {
  document.getElementById('loading').innerHTML = `
    <div style="text-align:center;max-width:400px;padding:20px">
      <div style="font-size:48px;margin-bottom:16px">üîê</div>
      <div style="font-size:18px;font-weight:700;margin-bottom:12px">Nicht eingeloggt</div>
      <div style="color:#a1a1aa;font-size:14px;line-height:1.6;margin-bottom:24px">
        Du musst dich zuerst anmelden um das Dashboard zu nutzen.
      </div>
      <a href="auth.html" class="btn btn-primary" style="text-decoration:none">
        üîë Zum Login
      </a>
      ${message ? `<div style="margin-top:16px;font-size:11px;color:#ef4444">${message}</div>` : ''}
    </div>
  `;
}

async function loadData() {
  const {data:pr} = await db.from('properties').select('*').eq('host_id', user.id).order('created_at', {ascending:false});
  properties = pr || [];
  const {data:bk} = await db.from('bookings').select('*,properties(name)').eq('host_id', user.id).order('check_in', {ascending:true});
  bookings = bk || [];
  
  // Load notifications
  await loadNotifications();
  
  // Load messages from Smoobu (if connected)
  if (smoobuConfig.connected && smoobuConfig.apiKey) {
    await loadSmoobuMessages();
  }
  
  // Initialize pricing data from properties
  initializePricingData();
  
  // Fetch events for properties (async, don't wait)
  fetchEventsForProperties();
}

// Load notifications from server (created by cron job)
async function loadNotifications() {
  try {
    const { data, error } = await db
      .from('notifications')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })
      .limit(50);
    
    if (!error && data) {
      notifications = data;
      unreadNotificationCount = data.filter(n => !n.read).length;
      updateNotificationBadge();
    }
  } catch (e) {
    console.log('Could not load notifications:', e);
  }
}

// Load messages from Smoobu for all active bookings
async function loadSmoobuMessages() {
  if (!smoobuConfig.connected || !smoobuConfig.apiKey) return;
  
  try {
    // Get active bookings (check-out within last 7 days or future)
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    const activeBookings = bookings.filter(b => 
      b.smoobu_id && 
      b.check_out >= sevenDaysAgo &&
      b.status !== 'cancelled'
    );
    
    console.log(`Loading messages for ${activeBookings.length} active bookings...`);
    
    // Clear existing chats
    chats = [];
    
    // Load messages for each booking (limit to 15 to avoid rate limits)
    for (const booking of activeBookings.slice(0, 15)) {
      try {
        const response = await fetch(
          `${SMOOBU_PROXY_URL}?action=messages&bookingId=${booking.smoobu_id}`,
          { headers: { 'x-smoobu-key': smoobuConfig.apiKey } }
        );
        
        if (!response.ok) continue;
        
        const data = await response.json();
        const messages = data.messages || data || [];
        
        if (!Array.isArray(messages) || messages.length === 0) continue;
        
        // Find the property for this booking
        const property = properties.find(p => p.id === booking.property_id);
        
        // Convert Smoobu messages to chat format
        // Log first message structure for debugging
        if (messages.length > 0 && !window._smoobuMsgLogged) {
          console.log('üìß SMOOBU MESSAGE STRUCTURE:');
          console.log(JSON.stringify(messages[0], null, 2));
          window._smoobuMsgLogged = true;
        }
        
        const chatMessages = messages.map(msg => {
          // Safely convert to string - handle numbers, null, undefined
          const safeStr = (val) => val === null || val === undefined ? '' : String(val).toLowerCase();
          
          const typeVal = safeStr(msg.type);
          const fromVal = safeStr(msg.from);
          const dirVal = safeStr(msg.direction);
          const sentByVal = safeStr(msg.sent_by);
          const senderVal = safeStr(msg.sender);
          
          // Smoobu type values: 1 = HostToGuest, 2 = GuestToHost
          // Check for HOST message indicators FIRST
          const isFromHost = 
            msg.type === 1 || 
            msg.type === '1' ||
            typeVal === 'host' || 
            typeVal === 'hosttoguest' ||
            typeVal === 'outgoing' ||
            typeVal === 'sent' ||
            fromVal === 'host' || 
            fromVal === 'me' ||
            fromVal === 'owner' ||
            dirVal === 'out' ||
            dirVal === 'outgoing' ||
            dirVal === 'outbound' ||
            sentByVal === 'host' ||
            sentByVal === 'owner' ||
            senderVal === 'host' ||
            senderVal === 'owner';
          
          // DEFAULT: Everything is from GUEST unless explicitly from host
          const finalFrom = isFromHost ? 'me' : 'them';
          
          console.log(`üì® Msg ${msg.id}: type=${msg.type} ‚Üí ${finalFrom === 'them' ? 'GUEST' : 'HOST'}`);
          
          return {
            id: msg.id || Math.random().toString(36).substr(2, 9),
            from: finalFrom,
            text: msg.message || msg.text || msg.body || msg.content || '',
            time: msg.created_at ? new Date(msg.created_at).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '',
            timestamp: msg.created_at || msg.timestamp || msg.date || new Date().toISOString(),
            ai: msg.ai || msg.sent_by_ai || false
          };
        }).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Get last message
        const lastMsg = chatMessages[chatMessages.length - 1];
        const unreadCount = chatMessages.filter(m => m.from === 'them' && !m.read).length;
        
        // Create initials from guest name
        const nameParts = (booking.guest_name || 'Gast').split(' ');
        const avatar = nameParts.map(p => p[0]).join('').toUpperCase().substring(0, 2);
        
        // Determine platform from booking source
        let platform = 'direct';
        const source = (booking.source || '').toLowerCase();
        if (source.includes('airbnb')) platform = 'airbnb';
        else if (source.includes('booking')) platform = 'booking';
        else if (source.includes('expedia') || source.includes('vrbo')) platform = 'expedia';
        
        // Add to chats
        chats.push({
          id: booking.smoobu_id,
          bookingId: booking.id,
          smoobuId: booking.smoobu_id,
          name: booking.guest_name || 'Gast',
          avatar: avatar,
          platform: platform,
          property: property?.name || 'Unbekannt',
          propertyId: booking.property_id,
          checkIn: booking.check_in,
          checkOut: booking.check_out,
          unread: unreadCount,
          lastMsg: lastMsg?.text?.substring(0, 50) || 'Keine Nachrichten',
          time: lastMsg?.time || '',
          messages: chatMessages
        });
        
        // Small delay to avoid rate limits
        await new Promise(r => setTimeout(r, 150));
        
      } catch (e) {
        console.error(`Error loading messages for booking ${booking.smoobu_id}:`, e);
      }
    }
    
    // Sort chats by last message time (newest first)
    chats.sort((a, b) => {
      const aLast = a.messages[a.messages.length - 1]?.timestamp || '';
      const bLast = b.messages[b.messages.length - 1]?.timestamp || '';
      return new Date(bLast) - new Date(aLast);
    });
    
    console.log(`Loaded ${chats.length} conversations with messages`);
    
    // Update unread badge
    const totalUnread = chats.reduce((sum, c) => sum + (c.unread || 0), 0);
    const badge = document.getElementById('msg-badge');
    if (badge) {
      badge.textContent = totalUnread;
      badge.style.display = totalUnread > 0 ? 'flex' : 'none';
    }
    
  } catch (error) {
    console.error('Error loading Smoobu messages:', error);
  }
}

// Update notification badge in header
function updateNotificationBadge() {
  const badge = document.getElementById('notification-badge');
  if (badge) {
    if (unreadNotificationCount > 0) {
      badge.textContent = unreadNotificationCount > 9 ? '9+' : unreadNotificationCount;
      badge.style.display = 'flex';
    } else {
      badge.style.display = 'none';
    }
  }
}

// Show notifications panel
function showNotifications() {
  const unreadList = notifications.filter(n => !n.read);
  const readList = notifications.filter(n => n.read).slice(0, 10);
  
  const renderNotification = (n) => `
    <div class="card" style="margin-bottom:8px;padding:12px;${!n.read ? 'border-left:3px solid #f97316;' : 'opacity:0.7;'}">
      <div style="display:flex;justify-content:space-between;align-items:start">
        <div style="flex:1">
          <div style="font-weight:600;font-size:13px">${n.title}</div>
          <div style="font-size:12px;color:#a1a1aa;margin-top:4px">${n.body || ''}</div>
          <div style="font-size:10px;color:#71717a;margin-top:6px">${new Date(n.created_at).toLocaleString('de-DE')}</div>
        </div>
        ${!n.read ? `<button class="btn btn-sm btn-secondary" onclick="markNotificationRead('${n.id}')" style="font-size:10px;padding:4px 8px">‚úì</button>` : ''}
      </div>
    </div>
  `;
  
  showModal(`
    <div class="modal-title">üîî Benachrichtigungen</div>
    
    ${unreadList.length > 0 ? `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <div style="font-size:12px;color:#f97316;font-weight:600">${unreadList.length} ungelesen</div>
        <button class="btn btn-sm btn-secondary" onclick="markAllNotificationsRead()" style="font-size:11px">Alle als gelesen</button>
      </div>
      <div style="max-height:300px;overflow-y:auto;margin-bottom:16px">
        ${unreadList.map(renderNotification).join('')}
      </div>
    ` : `
      <div style="text-align:center;padding:20px;color:#71717a">
        <div style="font-size:32px;margin-bottom:8px">‚úÖ</div>
        <div>Keine ungelesenen Benachrichtigungen</div>
      </div>
    `}
    
    ${readList.length > 0 ? `
      <div style="font-size:12px;color:#71717a;margin-bottom:8px">Fr√ºhere Benachrichtigungen</div>
      <div style="max-height:200px;overflow-y:auto">
        ${readList.map(renderNotification).join('')}
      </div>
    ` : ''}
    
    <button class="btn btn-secondary" onclick="hideModal()" style="width:100%;margin-top:16px">Schlie√üen</button>
  `);
}

// Mark single notification as read
async function markNotificationRead(id) {
  try {
    await db.from('notifications').update({ read: true }).eq('id', id);
    const notif = notifications.find(n => n.id === id);
    if (notif) notif.read = true;
    unreadNotificationCount = Math.max(0, unreadNotificationCount - 1);
    updateNotificationBadge();
    showNotifications(); // Refresh modal
  } catch (e) {
    console.log('Error marking notification read:', e);
  }
}

// Mark all notifications as read
async function markAllNotificationsRead() {
  try {
    await db.from('notifications').update({ read: true }).eq('user_id', user.id).eq('read', false);
    notifications.forEach(n => n.read = true);
    unreadNotificationCount = 0;
    updateNotificationBadge();
    showNotifications(); // Refresh modal
  } catch (e) {
    console.log('Error marking all notifications read:', e);
  }
}

async function initializePricingData() {
  if (properties.length === 0) {
    pricingData.properties = [];
    pricingData.dailyPrices = {};
    return;
  }
  
  // Calculate occupancy for each property based on bookings
  const now = new Date();
  const sixtyDaysFromNow = new Date(now.getTime() + 60 * 24 * 60 * 60 * 1000);
  
  pricingData.properties = properties.map(prop => {
    // Count booked days in next 60 days
    const propBookings = bookings.filter(b => 
      b.property_id === prop.id && 
      new Date(b.check_out) >= now &&
      new Date(b.check_in) <= sixtyDaysFromNow &&
      b.status !== 'cancelled'
    );
    
    let bookedDays = 0;
    propBookings.forEach(b => {
      const checkIn = new Date(Math.max(new Date(b.check_in), now));
      const checkOut = new Date(Math.min(new Date(b.check_out), sixtyDaysFromNow));
      const days = Math.ceil((checkOut - checkIn) / (1000 * 60 * 60 * 24));
      bookedDays += Math.max(0, days);
    });
    
    const occupancy = Math.min(100, Math.round((bookedDays / 60) * 100));
    const basePrice = prop.base_price || 80;
    
    return {
      id: prop.smoobu_id || prop.id,
      localId: prop.id,
      name: prop.name,
      city: prop.city || '',
      basePrice: basePrice,
      currentPrice: basePrice,
      occupancy: occupancy
    };
  });
  
  // Calculate daily prices for each property
  await calculateAllDailyPrices();
}

async function calculateAllDailyPrices() {
  const now = new Date();
  now.setHours(0, 0, 0, 0);
  
  for (const prop of pricingData.properties) {
    pricingData.dailyPrices[prop.id] = [];
    
    // Generate prices for next 60 days
    for (let i = 0; i < 60; i++) {
      const date = new Date(now);
      date.setDate(date.getDate() + i);
      const dateStr = date.toISOString().split('T')[0];
      
      const dayPrice = calculateDayPrice(prop, date, dateStr);
      pricingData.dailyPrices[prop.id].push(dayPrice);
    }
  }
  
  // After calculating, fetch current Smoobu prices and compare
  if (smoobuConfig.connected) {
    await compareWithSmoobuPrices();
  }
}

// Fetch current prices from Smoobu and mark already-applied prices
async function compareWithSmoobuPrices() {
  console.log('üîÑ Comparing prices with Smoobu...');
  
  const now = new Date();
  const startDate = now.toISOString().split('T')[0];
  const endDate = new Date(now.getTime() + 60 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
  
  let totalMatched = 0;
  
  for (const prop of pricingData.properties) {
    try {
      const response = await fetch(
        `${SMOOBU_PROXY_URL}?action=rates&apartments=${prop.id}&start_date=${startDate}&end_date=${endDate}`,
        {
          headers: {
            'x-smoobu-key': smoobuConfig.apiKey
          }
        }
      );
      
      if (!response.ok) {
        console.warn(`Failed to fetch rates for ${prop.name}: ${response.status}`);
        continue;
      }
      
      const data = await response.json();
      console.log(`Smoobu rates response for ${prop.name}:`, data);
      
      // Smoobu returns: { data: { [apartmentId]: { [date]: { price: X } } } }
      // Try multiple possible structures
      const apartmentRates = data?.data?.[prop.id] || data?.[prop.id] || data?.data || {};
      
      // Compare each day
      const dailyPrices = pricingData.dailyPrices[prop.id];
      if (!dailyPrices) continue;
      
      let matchedCount = 0;
      
      for (const day of dailyPrices) {
        const smoobuData = apartmentRates[day.date];
        if (smoobuData) {
          const smoobuPrice = parseFloat(smoobuData.price) || parseFloat(smoobuData.daily_price) || null;
          day.smoobuPrice = smoobuPrice;
          
          // Mark as applied if Smoobu price matches our calculated price (within ‚Ç¨1 tolerance)
          if (smoobuPrice !== null && Math.abs(smoobuPrice - day.finalPrice) <= 1) {
            day.applied = true;
            matchedCount++;
          } else if (smoobuPrice !== null) {
            // Prices don't match - show what Smoobu has vs what we calculated
            day.applied = false;
            console.log(`Price mismatch for ${day.date}: Smoobu=${smoobuPrice}, Calculated=${day.finalPrice}`);
          }
        }
      }
      
      totalMatched += matchedCount;
      console.log(`‚úÖ ${prop.name}: ${matchedCount} prices already match Smoobu`);
      
    } catch (error) {
      console.error(`Error fetching Smoobu prices for ${prop.name}:`, error);
    }
  }
  
  console.log(`üéØ Total prices already synced with Smoobu: ${totalMatched}`);
  
  // Re-render the page to show updated applied status
  if (currentPage === 'pricing') {
    renderPage();
  }
}

// =====================================================================
// EVENT IMPACT CLASSIFICATION SYSTEM - NEW
// Classifies events by impact: high, medium, low
// =====================================================================

/**
 * Classifies the impact level of an event
 * @param {Object} event - Ticketmaster Event object (normalized)
 * @returns {Object} { level: 'low'|'medium'|'high', multiplier: number, reason: string }
 */
function classifyEventImpact(event) {
  if (!event) return { level: 'none', multiplier: 1.0, reason: 'Kein Event' };
  
  const venueName = (event._embedded?.venues?.[0]?.name || '').toLowerCase();
  const eventName = (event.name || '').toLowerCase();
  const eventType = (event.classifications?.[0]?.segment?.name || '').toLowerCase();
  
  // HIGH IMPACT: Large venues, Major Events
  // Multiplier: 1.35 = +35% price increase
  const highImpactVenues = ['arena', 'stadion', 'stadium', 'olympia', 'halle', 'dome', 'allianz', 'veltins', 'signal iduna', 'mercedes-benz'];
  const highImpactEvents = ['concert', 'konzert', 'festival', 'bundesliga', 'champions league', 'finale', 'meisterschaft', 'weltmeisterschaft'];
  
  for (const keyword of highImpactVenues) {
    if (venueName.includes(keyword)) {
      return { level: 'high', multiplier: 1.35, reason: `Gro√üveranstaltung (${venueName.substring(0, 25)})` };
    }
  }
  
  for (const keyword of highImpactEvents) {
    if (eventName.includes(keyword) || eventType.includes(keyword)) {
      return { level: 'high', multiplier: 1.30, reason: `Major Event: ${event.name?.substring(0, 25)}...` };
    }
  }
  
  // MEDIUM IMPACT: Medium venues, regular concerts/sports
  // Multiplier: 1.15-1.20 = +15-20% price increase
  const mediumImpactVenues = ['theater', 'theatre', 'club', 'zentrum', 'center', 'hof', 'haus', 'philharmonie', 'oper', 'opera'];
  const mediumImpactTypes = ['music', 'sport', 'sports', 'comedy', 'musical'];
  
  for (const keyword of mediumImpactVenues) {
    if (venueName.includes(keyword)) {
      return { level: 'medium', multiplier: 1.20, reason: `Event: ${event.name?.substring(0, 30)}` };
    }
  }
  
  for (const keyword of mediumImpactTypes) {
    if (eventType.includes(keyword)) {
      return { level: 'medium', multiplier: 1.15, reason: `${eventType}: ${event.name?.substring(0, 25)}` };
    }
  }
  
  // LOW IMPACT: Default for all other recognized events
  // Multiplier: 1.08 = +8% price increase
  return { level: 'low', multiplier: 1.08, reason: `Event in der N√§he` };
}

/**
 * Gets all events for a specific date and city
 * @param {string} dateStr - ISO date (YYYY-MM-DD)
 * @param {string} propCity - City of the property
 * @returns {Array} Array of events with impact classification
 */
function getEventsForDateAndCity(dateStr, propCity) {
  if (!pricingData.events || pricingData.events.length === 0) return [];
  if (!propCity) return [];
  
  const propCityLower = propCity.toLowerCase().trim();
  
  return pricingData.events
    .filter(event => {
      // Match date first
      const eventDate = event.dates?.start?.localDate;
      if (eventDate !== dateStr) return false;
      
      // BEST MATCH: Use the _searchedCity tag we added when fetching
      if (event._searchedCity) {
        return event._searchedCity === propCityLower || 
               event._searchedCity.includes(propCityLower) || 
               propCityLower.includes(event._searchedCity);
      }
      
      // FALLBACK: Try to match from venue data
      const eventCity = (event._embedded?.venues?.[0]?.city?.name || '').toLowerCase().trim();
      const venueName = (event._embedded?.venues?.[0]?.name || '').toLowerCase();
      
      return eventCity.includes(propCityLower) || 
             propCityLower.includes(eventCity) ||
             venueName.includes(propCityLower);
    })
    .map(event => ({
      ...event,
      impact: classifyEventImpact(event)
    }));
}

/**
 * Calculates combined event multiplier for a day
 * Multiple events on the same day have cumulative effect (capped)
 * @param {Array} eventsWithImpact - Events with impact classification
 * @returns {Object} { multiplier: number, factors: Array, events: Array }
 */
function calculateEventMultiplier(eventsWithImpact) {
  if (!eventsWithImpact || eventsWithImpact.length === 0) {
    return { multiplier: 1.0, factors: [], events: [] };
  }
  
  // Sort by impact level (high first)
  const sorted = [...eventsWithImpact].sort((a, b) => {
    const order = { high: 0, medium: 1, low: 2 };
    return (order[a.impact.level] || 3) - (order[b.impact.level] || 3);
  });
  
  // Take highest impact event as base
  const primaryEvent = sorted[0];
  let baseMultiplier = primaryEvent.impact.multiplier;
  
  // Additional events give diminishing bonus (max +10% extra)
  const additionalBoost = Math.min(0.10, (sorted.length - 1) * 0.03);
  
  // Final multiplier (max 1.50 = +50%)
  const finalMultiplier = Math.min(1.50, baseMultiplier + additionalBoost);
  
  // Build factors array for display
  const factors = sorted.map(event => ({
    type: 'event',
    level: event.impact.level,
    label: `üé≠ ${event.impact.reason} +${Math.round((event.impact.multiplier - 1) * 100)}%`,
    boost: event.impact.multiplier - 1
  }));
  
  // Events array for detail view
  const events = sorted.map(event => ({
    name: event.name,
    venue: event._embedded?.venues?.[0]?.name || '',
    url: event.url,
    impact: event.impact.level
  }));
  
  return { multiplier: finalMultiplier, factors, events };
}

/**
 * Updates the pricing KPI display with event statistics
 * @param {Object} payload - { totalEvents, eventDays, avgImpact }
 */
function updatePricingKPI(payload = {}) {
  try {
    let totalEvents = 0, eventDays = 0, avgImpact = 0;
    
    if (Array.isArray(payload)) {
      totalEvents = payload.length;
      const days = new Set(payload.map(e => e?.date || e?.localDate || e?.startDate).filter(Boolean));
      eventDays = days.size;
    } else if (payload && typeof payload === 'object') {
      totalEvents = Number(payload.totalEvents ?? 0) || 0;
      eventDays = Number(payload.eventDays ?? 0) || 0;
      avgImpact = Number(payload.avgImpact ?? 0) || 0;
    }
    
    // Update KPI elements if they exist
    const eventsEl = document.querySelector('[data-kpi="events"]') || document.getElementById('kpiEvents');
    const daysEl = document.querySelector('[data-kpi="event-days"]') || document.getElementById('kpiDays');
    const impactEl = document.querySelector('[data-kpi="impact"]') || document.getElementById('kpiImpact');
    
    if (eventsEl) eventsEl.textContent = String(totalEvents);
    if (daysEl) daysEl.textContent = String(eventDays);
    if (impactEl) impactEl.textContent = `${avgImpact > 0 ? '+' : ''}${avgImpact}%`;
  } catch (e) {
    console.warn('updatePricingKPI failed:', e);
  }
}

// =====================================================================
// MODIFIED: calculateDayPrice with Event Impact Classification
// =====================================================================
function calculateDayPrice(prop, date, dateStr) {
  const basePrice = prop.basePrice;
  let finalPrice = basePrice;
  let factors = [];
  let events = [];
  
  // Strategy multipliers
  const strategyMultipliers = {
    conservative: { weekend: 0.08, holiday: 0.15, event: 0.10, lowDemand: -0.03 },
    balanced: { weekend: 0.15, holiday: 0.25, event: 0.20, lowDemand: -0.05 },
    aggressive: { weekend: 0.25, holiday: 0.40, event: 0.35, lowDemand: -0.08 }
  };
  const multipliers = strategyMultipliers[pricingData.strategy] || strategyMultipliers.balanced;
  
  const dayOfWeek = date.getDay();
  
  // 1. Weekend pricing (Fr, Sa)
  if (dayOfWeek === 5 || dayOfWeek === 6) {
    const boost = multipliers.weekend;
    finalPrice *= (1 + boost);
    factors.push({ type: 'weekend', label: `üóìÔ∏è Wochenende +${Math.round(boost * 100)}%`, boost });
  }
  
  // 2. Sunday slight boost
  if (dayOfWeek === 0) {
    const boost = multipliers.weekend * 0.5;
    finalPrice *= (1 + boost);
    factors.push({ type: 'sunday', label: `üóìÔ∏è Sonntag +${Math.round(boost * 100)}%`, boost });
  }
  
  // 3. Check holidays
  const holiday = germanHolidays.find(h => h.date === dateStr);
  if (holiday) {
    const boost = Math.min(holiday.boost, multipliers.holiday * 2);
    finalPrice *= (1 + boost);
    factors.push({ type: 'holiday', label: `üéâ ${holiday.name} +${Math.round(boost * 100)}%`, boost });
  }
  
  // =====================================================================
  // 4. EVENT PRICING - NEW IMPLEMENTATION
  // Uses the new event impact classification system
  // =====================================================================
  const eventsForDay = getEventsForDateAndCity(dateStr, prop.city);
  
  if (eventsForDay.length > 0) {
    // Calculate combined event multiplier
    const eventResult = calculateEventMultiplier(eventsForDay);
    
    // Apply strategy modifier to event multiplier
    // Conservative: Reduce event impact by 30%
    // Aggressive: Increase event impact by 20%
    let strategyModifier = 1.0;
    if (pricingData.strategy === 'conservative') {
      strategyModifier = 0.7;
    } else if (pricingData.strategy === 'aggressive') {
      strategyModifier = 1.2;
    }
    
    // Calculate final event boost (always positive, prices only go UP)
    const rawEventBoost = (eventResult.multiplier - 1) * strategyModifier;
    const eventBoost = Math.max(0, rawEventBoost); // Never negative
    
    if (eventBoost > 0) {
      finalPrice *= (1 + eventBoost);
      
      // Add event factors to display (max 2 to avoid clutter)
      const displayFactors = eventResult.factors.slice(0, 2);
      displayFactors.forEach(f => {
        // Recalculate displayed boost with strategy modifier
        const adjustedBoost = Math.max(0, f.boost * strategyModifier);
        factors.push({
          type: 'event',
          level: f.level,
          label: f.label.replace(/\+\d+%/, `+${Math.round(adjustedBoost * 100)}%`),
          boost: adjustedBoost
        });
      });
      
      // Show remaining events count if more than 2
      if (eventsForDay.length > 2) {
        factors.push({
          type: 'event-extra',
          label: `üé≠ +${eventsForDay.length - 2} weitere Events`,
          boost: 0
        });
      }
    }
    
    // Store events for detail view
    events = eventResult.events;
  }
  // =====================================================================
  // END EVENT PRICING
  // =====================================================================
  
  // 5. Check if date is booked (no adjustment needed, but mark it)
  const isBooked = bookings.some(b => {
    const checkIn = new Date(b.check_in);
    const checkOut = new Date(b.check_out);
    return b.property_id === prop.localId && 
           date >= checkIn && 
           date < checkOut && 
           b.status !== 'cancelled';
  });
  
  // 6. Low demand adjustment (only if NO positive factors exist)
  const hasPositiveFactors = factors.some(f => f.boost > 0);
  
  if (!hasPositiveFactors && dayOfWeek >= 1 && dayOfWeek <= 4) {
    // Check if there's a gap (no bookings before and after)
    const prevDay = new Date(date);
    prevDay.setDate(prevDay.getDate() - 1);
    const nextDay = new Date(date);
    nextDay.setDate(nextDay.getDate() + 1);
    
    const hasSurroundingBookings = bookings.some(b => {
      const checkIn = new Date(b.check_in);
      const checkOut = new Date(b.check_out);
      return b.property_id === prop.localId && 
             ((prevDay >= checkIn && prevDay < checkOut) || (nextDay >= checkIn && nextDay < checkOut));
    });
    
    if (!hasSurroundingBookings && prop.occupancy < 50) {
      const discount = multipliers.lowDemand;
      finalPrice *= (1 + discount);
      factors.push({ type: 'low', label: `üìâ Geringe Nachfrage ${Math.round(discount * 100)}%`, boost: discount });
    }
  }
  
  // Round to nearest euro
  finalPrice = Math.round(finalPrice);
  
  // Ensure price never falls below base price (prices only go UP)
  finalPrice = Math.max(finalPrice, basePrice);
  
  // Calculate total change percentage
  const changePercent = Math.round(((finalPrice - basePrice) / basePrice) * 100);
  
  return {
    date: dateStr,
    dayOfWeek,
    basePrice,
    finalPrice,
    changePercent,
    factors,
    events,
    isBooked,
    applied: false,
    // NEW: Event impact summary for calendar display
    eventImpact: events.length > 0 ? (events[0]?.impact || 'low') : null,
    eventCount: events.length
  };
}

// Fetch events from Ticketmaster for all property cities (via smoobu-proxy to avoid CORS)
async function fetchEventsForProperties() {
  // Only fetch once per hour
  const now = Date.now();
  if (pricingData.lastEventFetch && (now - pricingData.lastEventFetch) < 3600000) {
    return;
  }
  
  // Get unique cities from properties
  const cities = [...new Set(properties.map(p => p.city).filter(c => c && c.length > 2))];
  
  if (cities.length === 0) {
    console.log('No cities to fetch events for');
    return;
  }
  
  console.log('üé≠ Fetching events for cities:', cities);
  pricingData.events = [];
  
  const startDate = new Date().toISOString().split('T')[0];
  const endDate = new Date(Date.now() + 60 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
  
  // City aliases for Ticketmaster (handles umlauts and alternative names)
  const citySearchTerms = {
    'm√ºnchen': ['Munich', 'Muenchen'],
    'k√∂ln': ['Cologne', 'Koeln'],
    'd√ºsseldorf': ['Duesseldorf'],
    'n√ºrnberg': ['Nuremberg', 'Nuernberg'],
    'frankfurt': ['Frankfurt am Main', 'Frankfurt'],
    'hannover': ['Hanover', 'Hannover'],
    'z√ºrich': ['Zurich', 'Zuerich'],
    'wien': ['Vienna', 'Wien']
  };
  
  // Helper to get search terms for a city
  const getSearchTerms = (city) => {
    const cityLower = city.toLowerCase();
    for (const [key, aliases] of Object.entries(citySearchTerms)) {
      if (cityLower.includes(key) || key.includes(cityLower)) {
        return [city, ...aliases];
      }
    }
    return [city];
  };
  
  // Use smoobu-proxy with action=ticketmaster to avoid CORS issues
  for (const city of cities) {
    const searchTerms = getSearchTerms(city);
    let foundEvents = false;
    
    for (const searchTerm of searchTerms) {
      if (foundEvents) break; // Skip if already found events for this city
      
      try {
        const response = await fetch(
          `${SMOOBU_PROXY_URL}?action=ticketmaster&city=${encodeURIComponent(searchTerm)}&countryCode=DE&startDate=${startDate}&endDate=${endDate}&size=50`
        );
        
        if (response.ok) {
          const data = await response.json();
          if (data.events && data.events.length > 0) {
            // Tag events with original city name for matching
            const taggedEvents = data.events.map(e => ({
              ...e,
              _searchedCity: city.toLowerCase().trim() // Use original city name
            }));
            pricingData.events.push(...taggedEvents);
            console.log(`‚úÖ Found ${data.events.length} events in ${city} (searched: ${searchTerm})`);
            foundEvents = true;
          }
        }
      } catch (error) {
        console.error(`‚ùå Error fetching events for ${searchTerm}:`, error);
      }
    }
    
    if (!foundEvents) {
      console.log(`‚ÑπÔ∏è No events found in ${city} (tried: ${searchTerms.join(', ')})`);
    }
  }
  
  pricingData.lastEventFetch = now;
  
  // =====================================================================
  // DEBUG: Log event cities to diagnose matching issues
  // =====================================================================
  if (pricingData.events.length > 0) {
    const eventCities = [...new Set(pricingData.events.map(e => 
      e._embedded?.venues?.[0]?.city?.name || 'KEINE STADT'
    ))];
    console.log('üèôÔ∏è Event cities from Ticketmaster:', eventCities);
    console.log('üè† Property cities:', pricingData.properties.map(p => p.city));
    
    // Check for matching issues
    pricingData.properties.forEach(prop => {
      const propCity = prop.city?.toLowerCase().trim() || '';
      const matchingEvents = pricingData.events.filter(e => {
        const eventCity = (e._embedded?.venues?.[0]?.city?.name || '').toLowerCase().trim();
        return eventCity.includes(propCity) || propCity.includes(eventCity);
      });
      console.log(`üìç ${prop.name} (${prop.city}): ${matchingEvents.length} matching events`);
    });
  }
  
  // =====================================================================
  // NEW: Calculate event impact statistics
  // =====================================================================
  if (pricingData.events.length > 0) {
    const uniqueDates = new Set(pricingData.events.map(e => e.dates?.start?.localDate).filter(Boolean));
    const avgImpact = Math.round(pricingData.events.reduce((sum, e) => {
      const impact = classifyEventImpact(e);
      return sum + ((impact.multiplier - 1) * 100);
    }, 0) / pricingData.events.length);
    
    console.log(`üìä Event Statistics: ${pricingData.events.length} events, ${uniqueDates.size} event days, avg impact: +${avgImpact}%`);
    
    // Update KPI if the function exists
    if (typeof updatePricingKPI === 'function') {
      updatePricingKPI({
        totalEvents: pricingData.events.length,
        eventDays: uniqueDates.size,
        avgImpact: avgImpact
      });
    }
  }
  
  // Recalculate daily prices with events
  if (pricingData.events.length > 0) {
    await calculateAllDailyPrices();
    if (currentPage === 'pricing') {
      renderPage();
    }
  }
}

// Apply all suggested prices to Smoobu (day by day)
async function applyAllDailyPrices(propertyId) {
  const prop = pricingData.properties.find(p => p.id === propertyId);
  const dailyPrices = pricingData.dailyPrices[propertyId];
  
  if (!prop || !dailyPrices || !smoobuConfig.connected) {
    showToast('‚ùå Smoobu nicht verbunden');
    return;
  }
  
  showModal(`
    <div style="text-align:center;padding:40px">
      <div class="spinner" style="margin:0 auto 20px"></div>
      <div style="font-size:16px;font-weight:600">√úbertrage Preise zu Smoobu...</div>
      <div style="color:#71717a;font-size:13px;margin-top:8px">
        <span id="price-progress">0</span> / ${dailyPrices.filter(d => !d.isBooked).length} Tage
      </div>
    </div>
  `);
  
  let successCount = 0;
  let errorCount = 0;
  let processedCount = 0;
  let lastError = null;
  
  // Filter out booked days
  const daysToUpdate = dailyPrices.filter(d => !d.isBooked);
  
  for (let i = 0; i < daysToUpdate.length; i++) {
    const day = daysToUpdate[i];
    
    // Smoobu API format - dates as array of single dates
    const requestBody = {
      apartments: [parseInt(propertyId)],
      operations: [{
        dates: [day.date],  // Single date, not range
        daily_price: day.finalPrice
      }]
    };
    
    console.log('Sending to Smoobu:', JSON.stringify(requestBody));
    
    try {
      const response = await fetch(`${SMOOBU_PROXY_URL}?action=update-rates`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-smoobu-key': smoobuConfig.apiKey
        },
        body: JSON.stringify(requestBody)
      });
      
      const responseData = await response.json().catch(() => ({}));
      
      if (response.ok) {
        day.applied = true;
        successCount++;
      } else {
        console.error('Smoobu Error Response:', response.status, responseData);
        lastError = responseData;
        errorCount++;
        
        // Stop after first error to debug
        if (errorCount === 1) {
          console.error('First error details:', {
            status: response.status,
            propertyId: propertyId,
            date: day.date,
            price: day.finalPrice,
            response: responseData
          });
        }
      }
    } catch (error) {
      errorCount++;
      console.error('Network error applying price:', error);
    }
    
    processedCount++;
    document.getElementById('price-progress').textContent = processedCount;
    
    // Small delay to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 150));
  }
  
  hideModal();
  
  if (errorCount === 0) {
    showToast(`‚úÖ ${successCount} Tagespreise erfolgreich √ºbertragen!`);
  } else {
    showToast(`‚ö†Ô∏è ${successCount} √ºbertragen, ${errorCount} Fehler`);
    if (lastError) {
      console.error('Last error from Smoobu:', lastError);
    }
  }
  
  renderPage();
}

// Apply single day price
async function applySingleDayPrice(propertyId, dateStr) {
  const dailyPrices = pricingData.dailyPrices[propertyId];
  const day = dailyPrices?.find(d => d.date === dateStr);
  
  if (!day || !smoobuConfig.connected) {
    showToast('‚ùå Fehler beim √úbertragen');
    return;
  }
  
  try {
    const response = await fetch(`${SMOOBU_PROXY_URL}?action=update-rates`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-smoobu-key': smoobuConfig.apiKey
      },
      body: JSON.stringify({
        apartments: [parseInt(propertyId)],
        operations: [{
          dates: [dateStr],  // Single date
          daily_price: day.finalPrice
        }]
      })
    });
    
    if (response.ok) {
      day.applied = true;
      showToast(`‚úÖ Preis f√ºr ${formatDateShort(dateStr)} √ºbertragen`);
      renderPage();
    } else {
      const errorData = await response.json().catch(() => ({}));
      console.error('Price update error:', errorData);
      showToast('‚ùå Fehler beim √úbertragen');
    }
  } catch (error) {
    console.error('Error:', error);
    showToast('‚ùå Fehler beim √úbertragen');
  }
}

function formatDateShort(dateStr) {
  const d = new Date(dateStr);
  return d.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' });
}

// =====================
// TUTORIAL - Interactive Spotlight Tour
// =====================
function startTutorial() {
  tutorialCurrentStep = 0;
  document.getElementById('tutorial-overlay').style.display = 'block';
  
  // Build progress dots
  const progressContainer = document.getElementById('tutorial-progress');
  progressContainer.innerHTML = tutorialSteps.map((_, i) => 
    `<div class="tutorial-dot" data-step="${i}"></div>`
  ).join('');
  
  // Bind events
  document.getElementById('tutorial-next').onclick = nextTutorialStep;
  document.getElementById('tutorial-skip').onclick = endTutorial;
  
  // Delay backdrop fade
  setTimeout(() => {
    document.getElementById('tutorial-backdrop').classList.add('active');
  }, 50);
  
  showTutorialStep();
}

function showTutorialStep() {
  const step = tutorialSteps[tutorialCurrentStep];
  const totalSteps = tutorialSteps.length;
  
  // Update content
  document.getElementById('tutorial-step-icon').textContent = step.icon;
  document.getElementById('tutorial-step-label').textContent = `Schritt ${tutorialCurrentStep + 1} von ${totalSteps}`;
  document.getElementById('tutorial-step-title').textContent = step.title;
  document.getElementById('tutorial-step-desc').textContent = step.desc;
  document.getElementById('tutorial-next').textContent = step.button;
  
  // Update progress dots
  document.querySelectorAll('.tutorial-dot').forEach((dot, i) => {
    dot.className = 'tutorial-dot' + (i < tutorialCurrentStep ? ' done' : i === tutorialCurrentStep ? ' active' : '');
  });
  
  // Position spotlight and tooltip
  const spotlight = document.getElementById('tutorial-spotlight');
  const tooltip = document.getElementById('tutorial-tooltip');
  const arrow = document.getElementById('tutorial-arrow');
  
  if (step.target && step.position !== 'center') {
    const target = document.querySelector(step.target);
    if (target) {
      const rect = target.getBoundingClientRect();
      const padding = 8;
      
      // Position spotlight
      spotlight.style.display = 'block';
      spotlight.style.top = (rect.top - padding) + 'px';
      spotlight.style.left = (rect.left - padding) + 'px';
      spotlight.style.width = (rect.width + padding * 2) + 'px';
      spotlight.style.height = (rect.height + padding * 2) + 'px';
      spotlight.classList.add('pulse');
      
      // Position tooltip based on step.position
      arrow.className = '';
      
      if (step.position === 'right') {
        tooltip.style.left = (rect.right + 30) + 'px';
        tooltip.style.top = Math.max(20, rect.top - 20) + 'px';
        tooltip.style.transform = 'none';
        arrow.classList.add('left');
      } else if (step.position === 'left') {
        tooltip.style.left = (rect.left - 430) + 'px';
        tooltip.style.top = Math.max(20, rect.top - 20) + 'px';
        tooltip.style.transform = 'none';
        arrow.classList.add('right');
      } else if (step.position === 'bottom') {
        tooltip.style.left = rect.left + 'px';
        tooltip.style.top = (rect.bottom + 30) + 'px';
        tooltip.style.transform = 'none';
        arrow.classList.add('top');
      } else if (step.position === 'top') {
        tooltip.style.left = rect.left + 'px';
        tooltip.style.top = (rect.top - 250) + 'px';
        tooltip.style.transform = 'none';
        arrow.classList.add('bottom');
      }
    } else {
      // Target not found, center
      centerTooltip();
    }
  } else {
    // Center position (no spotlight)
    centerTooltip();
  }
}

function centerTooltip() {
  const spotlight = document.getElementById('tutorial-spotlight');
  const tooltip = document.getElementById('tutorial-tooltip');
  const arrow = document.getElementById('tutorial-arrow');
  
  spotlight.style.display = 'none';
  spotlight.classList.remove('pulse');
  tooltip.style.left = '50%';
  tooltip.style.top = '50%';
  tooltip.style.transform = 'translate(-50%, -50%)';
  arrow.className = 'hidden';
}

function nextTutorialStep() {
  tutorialCurrentStep++;
  
  if (tutorialCurrentStep >= tutorialSteps.length) {
    endTutorial();
  } else {
    // Animate tooltip out and in
    const tooltip = document.getElementById('tutorial-tooltip');
    tooltip.style.animation = 'none';
    tooltip.offsetHeight; // Trigger reflow
    tooltip.style.animation = 'tutorialFadeIn .4s ease';
    
    showTutorialStep();
  }
}

function endTutorial() {
  document.getElementById('tutorial-backdrop').classList.remove('active');
  
  setTimeout(() => {
    document.getElementById('tutorial-overlay').style.display = 'none';
    document.getElementById('tutorial-spotlight').style.display = 'none';
    localStorage.setItem('ps_tut_done', '1');
    
    // Save to Supabase for cross-device sync
    saveTutorialCompleted();
    
    // Show welcome toast
    showToast('üéâ Tutorial abgeschlossen! Viel Erfolg mit PilotStay!');
  }, 300);
}

// Save tutorial completed status to Supabase
async function saveTutorialCompleted() {
  try {
    await db.from('profiles').update({
      tutorial_completed: true
    }).eq('id', user.id);
  } catch (e) {
    console.log('Could not save tutorial status:', e);
  }
}

function resetTutorial() {
  localStorage.removeItem('ps_tut_done');
  // Also reset in Supabase
  try {
    db.from('profiles').update({ tutorial_completed: false }).eq('id', user.id);
  } catch (e) {}
  startTutorial();
}

// =====================
// USER
// =====================
function renderUser() {
  const n = profile?.first_name || user?.email?.split('@')[0] || 'User';
  document.getElementById('user-avatar').textContent = n[0].toUpperCase();
  document.getElementById('user-name').textContent = n + (profile?.last_name ? ' ' + profile.last_name : '');
}

// =====================
// NAVIGATION
// =====================
function setPage(p) {
  currentPage = p;
  document.querySelectorAll('.nav-item').forEach(i => i.classList.toggle('active', i.dataset.page === p));
  renderPage();
}

// =====================
// RENDER PAGE
// =====================
function renderPage() {
  const c = document.getElementById('content');
  const t = document.getElementById('page-title');
  const s = document.getElementById('page-subtitle');
  const a = document.getElementById('header-actions');
  const date = new Date().toLocaleDateString('de-DE', {weekday:'long', day:'numeric', month:'long', year:'numeric'});
  
  switch(currentPage) {
    case 'dashboard':
      t.textContent = 'Willkommen zur√ºck! üëã';
      s.textContent = date;
      a.innerHTML = '<button class="btn btn-primary" onclick="showAddProp()">+ Objekt</button>';
      c.innerHTML = renderDashboard();
      break;
    case 'bookings':
      t.textContent = 'Buchungen';
      s.textContent = bookings.length + ' Buchungen insgesamt';
      a.innerHTML = '<button class="btn btn-primary" onclick="showAddBook()">+ Buchung</button>';
      c.innerHTML = renderBookings();
      break;
    case 'properties':
      t.textContent = 'Objekte';
      s.textContent = properties.length + ' Objekte verwaltet';
      a.innerHTML = '<button class="btn btn-primary" onclick="showAddProp()">+ Objekt</button>';
      c.innerHTML = renderProperties();
      break;
    case 'partners':
      t.textContent = 'Partner';
      s.textContent = 'Finde Reinigungskr√§fte & Services';
      a.innerHTML = '';
      c.innerHTML = renderPartners();
      break;
    case 'messages':
      t.textContent = 'üí¨ Nachrichten';
      s.textContent = 'KI-gest√ºtzte G√§stekommunikation';
      a.innerHTML = automationSettings.smartReplies 
        ? '<span class="tag tag-purple">üß† Smart Replies aktiv</span>'
        : '<span class="tag tag-orange">üß† Smart Replies aus</span>';
      c.innerHTML = renderMessages();
      bindChatEvents();
      break;
    case 'reviews':
      t.textContent = '‚≠ê Bewertungen';
      s.textContent = 'KI-generierte Antwortvorschl√§ge';
      a.innerHTML = automationSettings.reviewReplies
        ? '<span class="tag tag-purple">üß† KI-Antworten aktiv</span>'
        : '<span class="tag tag-orange">üß† KI-Antworten aus</span>';
      c.innerHTML = renderReviews();
      break;
    case 'pricing':
      t.textContent = 'üí∞ Preisoptimierung';
      s.textContent = 'KI-gesteuerte dynamische Preise';
      a.innerHTML = automationSettings.autoPricing
        ? '<span class="tag tag-purple">üß† Auto-Pricing aktiv</span>'
        : '<span class="tag tag-orange">üß† Auto-Pricing aus</span>';
      c.innerHTML = renderPricing();
      break;
    case 'automation':
      t.textContent = 'Automatisierung';
      s.textContent = 'KI-Features & Auto-Pilot';
      a.innerHTML = '';
      c.innerHTML = renderAutomation();
      break;
    case 'settings':
      t.textContent = 'Einstellungen';
      s.textContent = 'Profil & Integrationen';
      a.innerHTML = '';
      c.innerHTML = renderSettings();
      break;
  }
}

// =====================
// DASHBOARD
// =====================
function renderDashboard() {
  // Calculate current month revenue - exclude cancelled bookings
  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();
  const lastMonth = currentMonth === 0 ? 11 : currentMonth - 1;
  const lastMonthYear = currentMonth === 0 ? currentYear - 1 : currentYear;
  
  // Filter out cancelled bookings for all calculations
  const activeBookings = bookings.filter(b => b.status !== 'cancelled');
  
  // Current month bookings (active only)
  const currentMonthBookings = activeBookings.filter(b => {
    const checkIn = new Date(b.check_in);
    return checkIn.getMonth() === currentMonth && checkIn.getFullYear() === currentYear;
  });
  
  // Last month bookings (active only)
  const lastMonthBookings = activeBookings.filter(b => {
    const checkIn = new Date(b.check_in);
    return checkIn.getMonth() === lastMonth && checkIn.getFullYear() === lastMonthYear;
  });
  
  const currentRev = currentMonthBookings.reduce((s,b) => s + (b.total_price||0), 0);
  const lastRev = lastMonthBookings.reduce((s,b) => s + (b.total_price||0), 0);
  const totalRev = activeBookings.reduce((s,b) => s + (b.total_price||0), 0);
  
  // Calculate percentage change
  let revChange = 0;
  let revChangeText = '';
  if (lastRev > 0) {
    revChange = Math.round(((currentRev - lastRev) / lastRev) * 100);
    revChangeText = revChange >= 0 ? `+${revChange}%` : `${revChange}%`;
  } else if (currentRev > 0) {
    revChangeText = '+100%';
    revChange = 100;
  } else {
    revChangeText = '‚Äî';
  }
  
  // Upcoming bookings - only active ones, future check-ins
  const upcoming = activeBookings
    .filter(b => new Date(b.check_in) >= new Date())
    .sort((a,b) => new Date(a.check_in) - new Date(b.check_in))
    .slice(0,5);
  const unreadMsgs = chats.reduce((s,c) => s + c.unread, 0);
  const pendingReviews = reviews.filter(r => !r.replied).length;
  
  return `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-icon">üí∞</div>
        <div class="stat-value">‚Ç¨${totalRev.toLocaleString()}</div>
        <div class="stat-label">Umsatz (Gesamt)</div>
        ${revChangeText !== '‚Äî' ? `<div class="stat-change ${revChange >= 0 ? 'up' : 'down'}">${revChangeText} vs. Vormonat</div>` : ''}
      </div>
      <div class="stat-card">
        <div class="stat-icon">üìÖ</div>
        <div class="stat-value">${activeBookings.length}</div>
        <div class="stat-label">Buchungen</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">üí¨</div>
        <div class="stat-value">${unreadMsgs}</div>
        <div class="stat-label">Neue Nachrichten</div>
      </div>
      <div class="stat-card">
        <div class="stat-icon">‚≠ê</div>
        <div class="stat-value">${pendingReviews}</div>
        <div class="stat-label">Unbeantwortete Bewertungen</div>
      </div>
    </div>
    
    <!-- AI Score -->
    ${(() => {
      // Calculate KI-Score dynamically
      const activeFeatures = [
        automationSettings.smartReplies,
        automationSettings.reviewReplies,
        automationSettings.autoPricing,
        automationSettings.autoJobs,
        smoobuConfig.connected
      ].filter(Boolean).length;
      
      const totalFeatures = 5;
      const score = properties.length > 0 ? Math.round((activeFeatures / totalFeatures) * 100) : 0;
      
      // Build active features tags
      const featureTags = [];
      if (automationSettings.smartReplies) featureTags.push('<span class="tag tag-purple">üí¨ Smart Replies</span>');
      if (automationSettings.reviewReplies) featureTags.push('<span class="tag tag-purple">‚≠ê Review-Antworten</span>');
      if (automationSettings.autoPricing) featureTags.push('<span class="tag tag-purple">üí∞ Auto-Pricing</span>');
      if (automationSettings.autoJobs) featureTags.push('<span class="tag tag-purple">üßπ Auto-Jobs</span>');
      if (smoobuConfig.connected) featureTags.push('<span class="tag tag-green">üîó Smoobu</span>');
      
      const inactiveCount = totalFeatures - activeFeatures;
      
      return `
        <div class="card card-ai" style="margin-bottom:24px">
          <div style="display:flex;align-items:center;gap:24px;flex-wrap:wrap">
            <div style="text-align:center;min-width:100px">
              <div style="font-size:48px;font-weight:700;color:${score >= 80 ? '#22c55e' : score >= 50 ? '#8b5cf6' : '#f97316'}">${score}%</div>
              <div style="font-size:12px;color:#a1a1aa">ü§ñ KI-Score</div>
            </div>
            <div style="flex:1;padding-left:20px;border-left:1px solid #27272a;min-width:200px">
              <div style="font-weight:600;margin-bottom:8px">${activeFeatures > 0 ? 'KI-Features aktiv:' : 'Keine KI-Features aktiv'}</div>
              <div style="display:flex;flex-wrap:wrap;gap:8px">
                ${featureTags.length > 0 ? featureTags.join('') : '<span style="color:#71717a;font-size:13px">Aktiviere Features in den Einstellungen</span>'}
              </div>
              ${inactiveCount > 0 && properties.length > 0 ? `
                <div style="margin-top:10px;font-size:12px;color:#a1a1aa">
                  üí° ${inactiveCount} weitere Feature${inactiveCount > 1 ? 's' : ''} verf√ºgbar
                </div>
              ` : ''}
            </div>
            <button class="btn btn-ai" onclick="setPage('automation')">Mehr KI ‚Üí</button>
          </div>
        </div>
      `;
    })()}
    
    <div class="grid-2">
      <div class="card">
        <div class="card-title">üìÖ Kommende Buchungen</div>
        ${upcoming.length ? upcoming.map(b => `
          <div class="list-item">
            <div class="list-icon">üë§</div>
            <div class="list-info">
              <div class="list-title">${b.guest_name}</div>
              <div class="list-subtitle">${b.properties?.name || ''} ¬∑ ${fmtDate(b.check_in)}</div>
            </div>
            <div style="color:#22c55e;font-weight:700">‚Ç¨${b.total_price||0}</div>
          </div>
        `).join('') : `
          <div class="empty-state" style="padding:30px">
            <div class="empty-icon">üì≠</div>
            <div class="empty-desc">Keine Buchungen</div>
          </div>
        `}
      </div>
      
      <div class="card">
        <div class="card-title">üè† Deine Objekte</div>
        ${properties.length ? properties.slice(0,4).map(p => `
          <div class="list-item">
            <div class="list-icon">${p.property_type === 'house' ? 'üè°' : 'üè¢'}</div>
            <div class="list-info">
              <div class="list-title">${p.name}</div>
              <div class="list-subtitle">${p.city || '-'}</div>
            </div>
            <span class="tag tag-green">Aktiv</span>
          </div>
        `).join('') : `
          <div class="empty-state" style="padding:30px">
            <div class="empty-icon">üèöÔ∏è</div>
            <button class="btn btn-primary" onclick="showAddProp()">+ Objekt</button>
          </div>
        `}
      </div>
    </div>
  `;
}

// =====================
// MESSAGES (AI)
// =====================
function renderMessages() {
  // If no Smoobu connection, show connection prompt
  if (!smoobuConfig.connected) {
    return '<div style="display:flex;align-items:center;justify-content:center;height:500px"><div style="text-align:center"><div style="font-size:64px;margin-bottom:16px">üí¨</div><div style="font-size:18px;font-weight:700;margin-bottom:8px">Smoobu verbinden</div><div style="color:#a1a1aa;margin-bottom:24px">Verbinde dein Smoobu-Konto um Nachrichten zu sehen.</div><button class="btn btn-primary" onclick="showSmoobuConnect()">üîó Verbinden</button></div></div>';
  }
  
  // If no chats
  if (chats.length === 0) {
    return '<div style="display:flex;align-items:center;justify-content:center;height:500px"><div style="text-align:center"><div style="font-size:64px;margin-bottom:16px">üì≠</div><div style="font-size:18px;font-weight:700">Keine Nachrichten</div><button class="btn btn-secondary" onclick="loadSmoobuMessages().then(()=>renderPage())" style="margin-top:16px">üîÑ Aktualisieren</button></div></div>';
  }
  
  const chat = activeChat ? chats.find(c => String(c.id) === String(activeChat)) : null;
  const smartReplies = (chat && automationSettings.smartReplies) ? getSmartReplies(chat) : [];
  
  // Build chat list HTML
  let chatListHtml = '';
  chats.forEach(c => {
    const isActive = String(activeChat) === String(c.id);
    const bgColor = isActive ? '#27272a' : 'transparent';
    const borderColor = isActive ? '#f97316' : 'transparent';
    chatListHtml += '<div onclick="selectChat(\'' + c.id + '\')" style="display:flex;gap:12px;padding:12px;border-radius:8px;cursor:pointer;margin-bottom:4px;background:' + bgColor + ';border-left:3px solid ' + borderColor + '">';
    chatListHtml += '<div style="width:40px;height:40px;border-radius:50%;background:#f97316;display:flex;align-items:center;justify-content:center;font-weight:600;color:#fff;flex-shrink:0">' + c.avatar + '</div>';
    chatListHtml += '<div style="flex:1;min-width:0"><div style="font-weight:600;font-size:13px">' + c.name + '</div><div style="font-size:10px;color:#71717a">' + (c.property || '') + '</div><div style="font-size:11px;color:#71717a;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">' + (c.lastMsg || '') + '</div></div>';
    chatListHtml += '</div>';
  });
  
  // Build messages HTML
  let messagesHtml = '';
  if (chat) {
    chat.messages.forEach(m => {
      const isGuest = m.from === 'them' || m.from === 'guest';
      const isAI = m.ai === true;
      
      if (isGuest) {
        messagesHtml += '<div style="align-self:flex-start;max-width:75%"><div style="font-size:10px;color:#71717a;margin-bottom:4px">üë§ ' + chat.name + ' ¬∑ ' + (m.time || '') + '</div><div style="background:#27272a;border:1px solid #3f3f46;padding:12px 16px;border-radius:4px 16px 16px 16px;font-size:13px">' + (m.text || '') + '</div></div>';
      } else if (isAI) {
        messagesHtml += '<div style="align-self:flex-end;max-width:75%"><div style="font-size:10px;color:#71717a;margin-bottom:4px;text-align:right">ü§ñ KI ¬∑ ' + (m.time || '') + '</div><div style="background:linear-gradient(135deg,#7c3aed,#8b5cf6);padding:12px 16px;border-radius:16px 16px 4px 16px;font-size:13px">' + (m.text || '') + '</div></div>';
      } else {
        messagesHtml += '<div style="align-self:flex-end;max-width:75%"><div style="font-size:10px;color:#71717a;margin-bottom:4px;text-align:right">üè† Du ¬∑ ' + (m.time || '') + '</div><div style="background:linear-gradient(135deg,#ea580c,#f97316);padding:12px 16px;border-radius:16px 16px 4px 16px;font-size:13px">' + (m.text || '') + '</div></div>';
      }
    });
  }
  
  // Build smart replies HTML
  let smartRepliesHtml = '';
  if (smartReplies.length > 0) {
    smartRepliesHtml = '<div style="padding:12px 16px;border-top:1px solid #27272a;background:#1f1f23"><div style="font-size:11px;color:#71717a;margin-bottom:8px">üß† KI-Vorschl√§ge</div><div style="display:flex;flex-wrap:wrap;gap:8px">';
    smartReplies.forEach((r, i) => {
      smartRepliesHtml += '<button onclick="sendSmartReply(' + i + ')" style="background:#27272a;border:1px solid #3f3f46;padding:8px 12px;border-radius:16px;font-size:12px;cursor:pointer;color:#fafafa">' + r + '</button>';
    });
    smartRepliesHtml += '</div></div>';
  }
  
  // Main layout - TWO COLUMNS SIDE BY SIDE
  return '<div style="display:flex;flex-direction:row;gap:16px;height:700px">' +
    // LEFT COLUMN - Chat List
    '<div style="width:320px;flex-shrink:0;background:#18181b;border-radius:12px;display:flex;flex-direction:column;overflow:hidden">' +
      '<div style="padding:14px 16px;border-bottom:1px solid #27272a;display:flex;justify-content:space-between;align-items:center">' +
        '<span style="font-weight:600">Konversationen (' + chats.length + ')</span>' +
        '<div style="display:flex;gap:8px;align-items:center">' +
          (automationSettings.smartReplies ? '<span class="tag tag-green" style="font-size:9px">KI aktiv</span>' : '<span class="tag tag-orange" style="font-size:9px">KI aus</span>') +
          '<button class="btn btn-sm btn-secondary" onclick="loadSmoobuMessages().then(()=>renderPage())" style="padding:4px 8px">üîÑ</button>' +
        '</div>' +
      '</div>' +
      '<div style="flex:1;overflow-y:auto;padding:8px">' + chatListHtml + '</div>' +
    '</div>' +
    // RIGHT COLUMN - Chat Window
    '<div style="flex:1;background:#18181b;border-radius:12px;display:flex;flex-direction:column;overflow:hidden">' +
      (chat ? 
        // Header
        '<div style="padding:14px 16px;border-bottom:1px solid #27272a;display:flex;align-items:center;gap:12px">' +
          '<div style="width:44px;height:44px;border-radius:50%;background:#f97316;display:flex;align-items:center;justify-content:center;font-weight:600;color:#fff">' + chat.avatar + '</div>' +
          '<div style="flex:1"><div style="font-weight:600;font-size:15px">' + chat.name + '</div><div style="font-size:11px;color:#71717a">' + (chat.property || '') + '</div></div>' +
          '<span class="tag tag-' + (chat.platform === 'airbnb' ? 'red' : chat.platform === 'booking' ? 'blue' : 'orange') + '">' + (chat.platform === 'airbnb' ? 'Airbnb' : chat.platform === 'booking' ? 'Booking' : 'Direkt') + '</span>' +
        '</div>' +
        // Messages
        '<div id="chat-messages" style="flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:16px">' + messagesHtml + '</div>' +
        // Smart Replies
        smartRepliesHtml +
        // Input
        '<div style="padding:14px 16px;border-top:1px solid #27272a;display:flex;gap:10px;align-items:center">' +
          '<button class="btn btn-secondary" onclick="showAiCompose()" style="padding:10px 12px">ü§ñ</button>' +
          '<input type="text" id="msg-input" class="input" placeholder="Nachricht schreiben..." style="flex:1" onkeypress="if(event.key===\'Enter\')sendMessage()">' +
          '<button class="btn btn-primary" onclick="sendMessage()">Senden</button>' +
        '</div>'
      : 
        // No chat selected
        '<div style="flex:1;display:flex;align-items:center;justify-content:center"><div style="text-align:center;color:#71717a"><div style="font-size:48px;margin-bottom:12px">üí¨</div><div>W√§hle eine Konversation</div></div></div>'
      ) +
    '</div>' +
  '</div>';
}

// AI-powered Smart Replies
async function getSmartRepliesAI(chat) {
  const lastMsg = chat.messages[chat.messages.length - 1];
  if (!lastMsg || lastMsg.from !== 'them') return [];
  
  // If AI proxy is not available, use fallback directly
  // This prevents 401 errors from showing up
  try {
    const session = await db.auth.getSession();
    const token = session?.data?.session?.access_token;
    
    // If no token, use fallback
    if (!token) {
      console.log('No auth token, using fallback replies');
      return getSmartRepliesFallback(chat);
    }
    
    const response = await fetch(AI_PROXY_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + token
      },
      body: JSON.stringify({
        action: 'smart-replies',
        data: {
          guestName: chat.name,
          guestMessage: lastMsg.text,
          conversationHistory: chat.messages.slice(-6).map(m => m.text),
          propertyName: chat.property
        }
      })
    });
    
    // If unauthorized or error, use fallback silently
    if (!response.ok) {
      console.log('AI proxy unavailable (status ' + response.status + '), using fallback');
      return getSmartRepliesFallback(chat);
    }
    
    const data = await response.json();
    return data.replies || getSmartRepliesFallback(chat);
    
  } catch (error) {
    // Silently fall back - don't show error to user
    console.log('AI Smart Replies fallback:', error.message);
    return getSmartRepliesFallback(chat);
  }
}

// Fallback if AI is unavailable
function getSmartRepliesFallback(chat) {
  const lastMsg = chat.messages[chat.messages.length - 1];
  if (lastMsg.from !== 'them') return [];
  
  const text = lastMsg.text.toLowerCase();
  
  if (text.includes('wlan') || text.includes('wifi') || text.includes('internet')) {
    return ['Das WLAN-Passwort ist: Guest2024 üì∂', 'Die Zugangsdaten findest du im G√§stebuch!', 'Ich schicke dir die Infos gleich per SMS.'];
  }
  if (text.includes('check') || text.includes('auschecken') || text.includes('sp√§ter')) {
    return ['Klar, sp√§tes Checkout bis 14 Uhr ist kein Problem! üëç', 'Leider ist das Objekt danach gebucht. Checkout ist um 11 Uhr.', 'Ich schaue kurz nach und melde mich!'];
  }
  if (text.includes('parkplatz') || text.includes('parken')) {
    return ['Kostenlose Parkpl√§tze sind direkt vor dem Haus! üöó', 'Es gibt eine Tiefgarage im Geb√§ude.', 'Am besten auf der Stra√üe parken - ist kostenlos.'];
  }
  
  return ['Danke f√ºr deine Nachricht! üòä', 'Ich melde mich gleich!', 'Alles klar, verstanden!'];
}

// Cache for AI replies to avoid repeated calls
let smartRepliesCache = {};

function getSmartReplies(chat) {
  // Return cached if available
  const cacheKey = `${chat.id}-${chat.messages.length}`;
  if (smartRepliesCache[cacheKey]) {
    return smartRepliesCache[cacheKey];
  }
  
  // Always return fallback immediately, then try AI in background
  const fallback = getSmartRepliesFallback(chat);
  
  // Cache the fallback
  if (!smartRepliesCache[cacheKey]) {
    smartRepliesCache[cacheKey] = fallback;
  }
  
  // Fetch AI replies in background if enabled (but don't wait)
  if (automationSettings.smartReplies) {
    getSmartRepliesAI(chat).then(replies => {
      if (replies && replies.length > 0) {
        smartRepliesCache[cacheKey] = replies;
        // Re-render if still on same chat
        if (String(activeChat) === String(chat.id) && currentPage === 'chat') {
          renderPage();
        }
      }
    }).catch(e => console.log('AI replies error:', e));
  }
  
  return smartRepliesCache[cacheKey] || fallback;
}

// Force refresh AI replies
async function refreshSmartReplies(chatId) {
  const chat = chats.find(c => c.id == chatId);
  if (!chat) return;
  
  const cacheKey = `${chat.id}-${chat.messages.length}`;
  delete smartRepliesCache[cacheKey];
  
  showToast('ü§ñ Generiere neue Vorschl√§ge...');
  
  const replies = await getSmartRepliesAI(chat);
  if (replies && replies.length > 0) {
    smartRepliesCache[cacheKey] = replies;
    renderPage();
    showToast('‚úÖ Neue Vorschl√§ge bereit!');
  }
}

async function sendSmartReply(idx) {
  const chat = chats.find(c => c.id == activeChat);
  if (!chat) return;
  
  const replies = getSmartReplies(chat);
  const text = replies[idx];
  if (!text) return;
  
  const lastGuestMsg = chat.messages.filter(m => m.from === 'them').pop();
  
  // Create message with unique ID for feedback tracking
  const msgId = 'msg_' + Date.now();
  
  // Add to local chat immediately (optimistic update)
  chat.messages.push({
    id: msgId,
    from: 'me', 
    text, 
    time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}), 
    ai: true,
    needsFeedback: automationSettings.aiLearning
  });
  chat.unread = 0;
  chat.lastMsg = text;
  
  renderPage();
  scrollChatToBottom();
  
  // Send via Smoobu if connected
  if (smoobuConfig.connected && chat.smoobuId) {
    try {
      const result = await sendMessageViaSmoobu(chat.smoobuId, text);
      if (result.success) {
        showToast('‚úÖ Nachricht gesendet');
      } else {
        showToast('‚ö†Ô∏è Lokal gespeichert, Smoobu-Versand fehlgeschlagen');
        console.error('Smoobu send error:', result.error);
      }
    } catch (e) {
      console.error('Error sending via Smoobu:', e);
      showToast('‚ö†Ô∏è Lokal gespeichert');
    }
  } else {
    showToast('üí¨ Nachricht hinzugef√ºgt (Demo-Modus)');
  }
  
  // Track that this reply was used (positive signal for learning)
  if (automationSettings.aiLearning && lastGuestMsg) {
    trackAiUsage({
      type: 'smart-reply',
      guestMessage: lastGuestMsg.text,
      aiResponse: text,
      used: true,
      timestamp: new Date().toISOString()
    });
  }
}

// Track AI usage for learning
function trackAiUsage(data) {
  if (!automationSettings.aiLearning) return;
  
  aiContext.feedbackHistory.push({
    ...data,
    id: 'fb_' + Date.now()
  });
  
  // Keep only last 100 entries
  if (aiContext.feedbackHistory.length > 100) {
    aiContext.feedbackHistory = aiContext.feedbackHistory.slice(-100);
  }
  
  localStorage.setItem('ai_context', JSON.stringify(aiContext));
}

// Feedback functions for AI messages
function rateAiMessage(msgId, rating) {
  const chat = chats.find(c => c.id == activeChat);
  if (!chat) return;
  
  const msg = chat.messages.find(m => m.id === msgId);
  if (!msg) return;
  
  msg.feedback = rating;
  msg.needsFeedback = false;
  
  // Find the guest message this was responding to
  const msgIndex = chat.messages.indexOf(msg);
  const guestMsgs = chat.messages.slice(0, msgIndex).filter(m => m.from === 'them');
  const lastGuestMsg = guestMsgs[guestMsgs.length - 1];
  
  // Save feedback for learning
  trackAiUsage({
    type: 'feedback',
    guestMessage: lastGuestMsg?.text || '',
    aiResponse: msg.text,
    rating: rating, // 'positive' or 'negative'
    timestamp: new Date().toISOString()
  });
  
  // If positive, save as successful reply
  if (rating === 'positive' && lastGuestMsg) {
    saveSuccessfulReply(lastGuestMsg.text, msg.text);
  }
  
  showToast(rating === 'positive' ? 'üëç Danke f√ºr das Feedback!' : 'üëé Feedback gespeichert - KI wird verbessert');
  renderPage();
}

// Save successful replies for future use
function saveSuccessfulReply(guestMessage, aiResponse) {
  // Extract keywords from guest message
  const keywords = guestMessage.toLowerCase()
    .split(/\s+/)
    .filter(w => w.length > 3)
    .slice(0, 5);
  
  aiContext.savedReplies.push({
    keywords,
    guestMessage,
    aiResponse,
    usageCount: 1,
    timestamp: new Date().toISOString()
  });
  
  // Keep only last 50 saved replies
  if (aiContext.savedReplies.length > 50) {
    aiContext.savedReplies = aiContext.savedReplies.slice(-50);
  }
  
  localStorage.setItem('ai_context', JSON.stringify(aiContext));
}

async function sendMessage() {
  const input = document.getElementById('msg-input');
  const text = input.value.trim();
  if (!text || !activeChat) return;
  
  const chat = chats.find(c => c.id == activeChat);
  if (!chat) return;
  
  // Disable input while sending
  input.disabled = true;
  const sendBtn = document.querySelector('.chat-input button');
  if (sendBtn) sendBtn.disabled = true;
  
  // Add message locally first (optimistic UI)
  const newMsg = {
    id: Date.now(),
    from: 'me', 
    text, 
    time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}),
    sending: true
  };
  chat.messages.push(newMsg);
  chat.lastMsg = text;
  input.value = '';
  renderPage();
  scrollChatToBottom();
  
  // Send to Smoobu if connected
  if (smoobuConfig.connected && chat.smoobuId) {
    try {
      const response = await fetch(`${SMOOBU_PROXY_URL}?action=send-message`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-smoobu-key': smoobuConfig.apiKey
        },
        body: JSON.stringify({
          bookingId: chat.smoobuId,
          messageBody: text
        })
      });
      
      if (response.ok) {
        newMsg.sending = false;
        showToast('‚úÖ Nachricht gesendet');
      } else {
        const errorData = await response.json().catch(() => ({}));
        console.error('Smoobu send error:', errorData);
        newMsg.error = true;
        showToast('‚ö†Ô∏è Nachricht lokal gespeichert (Smoobu-Fehler)');
      }
    } catch (error) {
      console.error('Send message error:', error);
      newMsg.error = true;
      showToast('‚ö†Ô∏è Nachricht konnte nicht gesendet werden');
    }
  } else {
    newMsg.sending = false;
    showToast('üí¨ Nachricht gespeichert (Smoobu nicht verbunden)');
  }
  
  // Re-enable input
  input.disabled = false;
  if (sendBtn) sendBtn.disabled = false;
  renderPage();
}

// AI Compose Helper - shows quick compose options
function showAiCompose() {
  const chat = chats.find(c => c.id == activeChat);
  if (!chat) return;
  
  showModal(`
    <div class="modal-title">ü§ñ KI-Nachricht verfassen</div>
    <div style="margin-bottom:16px;color:#a1a1aa;font-size:13px">
      W√§hle eine Vorlage und die KI erstellt eine passende Nachricht f√ºr ${chat.name}
    </div>
    
    <div style="display:grid;gap:12px;margin-bottom:20px">
      <button class="btn btn-secondary" style="text-align:left;padding:16px" onclick="composeAiMessage('welcome')">
        <div style="font-weight:600">üëã Willkommensnachricht</div>
        <div style="font-size:12px;color:#a1a1aa">Begr√º√üe den Gast herzlich</div>
      </button>
      <button class="btn btn-secondary" style="text-align:left;padding:16px" onclick="composeAiMessage('check-in-instructions')">
        <div style="font-weight:600">üîë Check-in Anleitung</div>
        <div style="font-size:12px;color:#a1a1aa">Infos zum Ankommen und Schl√ºssel</div>
      </button>
      <button class="btn btn-secondary" style="text-align:left;padding:16px" onclick="composeAiMessage('checkout-reminder')">
        <div style="font-weight:600">üèÅ Checkout Erinnerung</div>
        <div style="font-size:12px;color:#a1a1aa">Freundliche Erinnerung an den Auszug</div>
      </button>
      <button class="btn btn-secondary" style="text-align:left;padding:16px" onclick="composeAiMessage('wifi-info')">
        <div style="font-weight:600">üì∂ WLAN-Infos</div>
        <div style="font-size:12px;color:#a1a1aa">Zugangsdaten und Internet</div>
      </button>
      <button class="btn btn-secondary" style="text-align:left;padding:16px" onclick="composeAiMessage('thank-you')">
        <div style="font-weight:600">üôè Dankesnachricht</div>
        <div style="font-size:12px;color:#a1a1aa">Bedanke dich nach dem Aufenthalt</div>
      </button>
      <button class="btn btn-secondary" style="text-align:left;padding:16px" onclick="composeAiMessage('problem-response')">
        <div style="font-weight:600">üîß Problem-Antwort</div>
        <div style="font-size:12px;color:#a1a1aa">Reagiere auf ein gemeldetes Problem</div>
      </button>
    </div>
    
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
    </div>
  `);
}

async function composeAiMessage(intent) {
  const chat = chats.find(c => c.id == activeChat);
  if (!chat) return;
  
  hideModal();
  showToast('ü§ñ Generiere Nachricht...');
  
  // Find property info
  const booking = bookings.find(b => b.guest_name?.includes(chat.name.split(' ')[0]));
  const property = booking ? properties.find(p => p.id === booking.property_id) : properties[0];
  
  // Fallback templates for when AI proxy is unavailable
  const templates = {
    'welcome': `Hallo ${chat.name}! üëã\n\nHerzlich willkommen! Ich freue mich, dass du bei uns √ºbernachtest.\n\nBei Fragen bin ich jederzeit erreichbar.\n\nViele Gr√º√üe`,
    'checkin': `Hallo ${chat.name}! üîë\n\nHier sind deine Check-in Infos:\n\nüìç Adresse: ${property?.address || 'Siehe Buchungsbest√§tigung'}\n‚è∞ Check-in: ab ${property?.checkin_time || '15:00'} Uhr\nüì∂ WLAN: ${property?.wifi_password || 'Guest2024'}\n\nBis bald!`,
    'checkout': `Hallo ${chat.name}! üè†\n\nKurze Erinnerung: Der Checkout ist morgen bis ${property?.checkout_time || '11:00'} Uhr.\n\nBitte denke daran:\n- Fenster schlie√üen\n- M√ºll mitnehmen\n- Schl√ºssel an der Rezeption abgeben\n\nVielen Dank f√ºr deinen Aufenthalt! ‚≠ê`,
    'wifi': `Hallo ${chat.name}! üì∂\n\nHier sind die WLAN-Daten:\n\nNetzwerk: ${property?.name || 'GuestWiFi'}\nPasswort: ${property?.wifi_password || 'Guest2024'}\n\nViel Spa√ü beim Surfen!`,
    'thanks': `Hallo ${chat.name}! üôè\n\nVielen Dank f√ºr deinen Aufenthalt bei uns!\n\nWir w√ºrden uns sehr √ºber eine positive Bewertung freuen. ‚≠ê\n\nBis zum n√§chsten Mal!`,
    'problem': `Hallo ${chat.name}!\n\nVielen Dank, dass du dich gemeldet hast. Es tut mir leid zu h√∂ren, dass es ein Problem gibt.\n\nIch k√ºmmere mich sofort darum und melde mich schnellstm√∂glich bei dir.\n\nViele Gr√º√üe`
  };
  
  try {
    const session = await db.auth.getSession();
    const token = session?.data?.session?.access_token;
    
    let message = templates[intent] || templates['welcome'];
    
    // Try AI if available
    if (token) {
      try {
        const response = await fetch(AI_PROXY_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
          },
          body: JSON.stringify({
            action: 'compose-message',
            data: {
              intent: intent,
              guestName: chat.name,
              propertyName: property?.name,
              customDetails: property ? `WLAN: ${property.wifi_password || 'Guest2024'}, Check-in: ${property.checkin_time || '15:00'}, Checkout: ${property.checkout_time || '11:00'}` : null,
              tone: 'friendly'
            }
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.message) message = data.message;
        }
      } catch (e) {
        console.log('AI compose fallback:', e.message);
      }
    }
    
    // Show message for editing before sending
    showModal(`
      <div class="modal-title">‚úèÔ∏è Nachricht bearbeiten</div>
      <textarea id="composed-message" style="width:100%;min-height:150px;background:#18181b;border:1px solid #27272a;border-radius:8px;padding:12px;color:#fafafa;font-size:14px;resize:vertical">${message}</textarea>
      <div style="display:flex;gap:12px;margin-top:16px">
        <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
        <button class="btn btn-ai" onclick="sendComposedMessage()" style="flex:1">üì§ Senden</button>
      </div>
    `);
    
  } catch (error) {
    console.log('AI Compose fallback:', error.message);
    // Use template even on error
    const message = templates[intent] || templates['welcome'];
    showModal(`
      <div class="modal-title">‚úèÔ∏è Nachricht bearbeiten</div>
      <textarea id="composed-message" style="width:100%;min-height:150px;background:#18181b;border:1px solid #27272a;border-radius:8px;padding:12px;color:#fafafa;font-size:14px;resize:vertical">${message}</textarea>
      <div style="display:flex;gap:12px;margin-top:16px">
        <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
        <button class="btn btn-ai" onclick="sendComposedMessage()" style="flex:1">üì§ Senden</button>
      </div>
    `);
  }
}

async function sendComposedMessage() {
  const textarea = document.getElementById('composed-message');
  const text = textarea?.value?.trim();
  
  if (!text || !activeChat) {
    hideModal();
    return;
  }
  
  const chat = chats.find(c => String(c.id) === String(activeChat));
  if (!chat) {
    hideModal();
    return;
  }
  
  // Add to local chat
  chat.messages.push({
    id: 'composed_' + Date.now(),
    from: 'me', 
    text, 
    time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}), 
    ai: true
  });
  chat.lastMsg = text;
  
  hideModal();
  renderPage();
  scrollChatToBottom();
  
  // Send via Smoobu if connected
  if (smoobuConfig.connected && chat.smoobuId) {
    try {
      const result = await sendMessageViaSmoobu(chat.smoobuId, text);
      if (result.success) {
        showToast('‚úÖ Nachricht gesendet');
      } else {
        showToast('‚ö†Ô∏è Lokal gespeichert, Smoobu-Versand fehlgeschlagen');
        console.error('Smoobu send error:', result.error);
      }
    } catch (e) {
      console.error('Error sending composed message:', e);
      showToast('‚ö†Ô∏è Lokal gespeichert');
    }
  } else {
    showToast('üí¨ Nachricht hinzugef√ºgt (Demo-Modus)');
  }
}

function scrollChatToBottom() {
  setTimeout(() => {
    const el = document.getElementById('chat-messages');
    if (el) {
      el.scrollTop = el.scrollHeight;
    }
  }, 50);
}

// Select a chat conversation
function selectChat(chatId) {
  // Keep ID as string for comparison (Smoobu IDs can be large numbers)
  activeChat = String(chatId);
  const chat = chats.find(c => String(c.id) === activeChat);
  if (chat) {
    chat.unread = 0;
    console.log(`Selected chat: ${chat.name} (${chat.messages.length} messages)`);
  } else {
    console.warn(`Chat not found for ID: ${chatId}`);
  }
  renderPage();
  // Scroll to bottom after render
  setTimeout(scrollChatToBottom, 100);
}

function bindChatEvents() {
  document.querySelectorAll('.chat-item[data-chat-id]').forEach(el => {
    el.onclick = () => {
      const chatId = el.dataset.chatId;
      selectChat(chatId);
    };
  });
}

// Scroll chat messages to bottom
function scrollChatToBottom() {
  const messagesContainer = document.getElementById('chat-messages');
  if (messagesContainer) {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
}

// =====================
// REVIEWS (AI)
// =====================
function renderReviews() {
  const validRatings = reviews.filter(r => r.rating);
  const avgRating = validRatings.length ? (validRatings.reduce((s,r) => s + r.rating, 0) / validRatings.length).toFixed(1) : '-';
  const pending = reviews.filter(r => !r.replied).length;
  const unverified = reviews.filter(r => r.status === 'unverified').length;
  const aiEnabled = automationSettings.reviewReplies;
  
  // Tab state
  const activeTab = window.reviewsActiveTab || 'all';
  
  // Filter reviews based on tab
  let filteredReviews = reviews;
  if (activeTab === 'unverified') {
    filteredReviews = reviews.filter(r => r.status === 'unverified');
  } else if (activeTab === 'pending') {
    filteredReviews = reviews.filter(r => !r.replied);
  }
  
  // If no reviews, show setup info
  if (reviews.length === 0) {
    return `
      <div style="max-width:700px;margin:40px auto">
        <div class="card" style="text-align:center;padding:48px 32px">
          <div style="font-size:64px;margin-bottom:20px">‚≠ê</div>
          <div style="font-size:22px;font-weight:700;margin-bottom:12px">Bewertungen importieren</div>
          <div style="color:#a1a1aa;margin-bottom:32px;line-height:1.6">
            Importiere deine Airbnb-Bewertungen automatisch per E-Mail-Weiterleitung.<br>
            Sobald du eine neue Bewertung erh√§ltst, wird sie hier angezeigt.
          </div>
          <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
            <button class="btn btn-primary" onclick="showEmailSetupModal()">üìß E-Mail-Import einrichten</button>
            <button class="btn btn-secondary" onclick="showAddReviewModal()">‚ûï Manuell hinzuf√ºgen</button>
          </div>
        </div>
        
        <div class="card" style="margin-top:20px">
          <div class="card-title">üìã So funktioniert der E-Mail-Import</div>
          <div style="display:flex;flex-direction:column;gap:16px">
            <div style="display:flex;gap:12px;align-items:flex-start">
              <div style="background:#f97316;color:#fff;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;flex-shrink:0">1</div>
              <div><div style="font-weight:600">E-Mail-Adresse kopieren</div><div style="font-size:13px;color:#a1a1aa">Klicke auf "E-Mail-Import einrichten" um deine pers√∂nliche Weiterleitungsadresse zu erhalten.</div></div>
            </div>
            <div style="display:flex;gap:12px;align-items:flex-start">
              <div style="background:#f97316;color:#fff;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;flex-shrink:0">2</div>
              <div><div style="font-weight:600">Airbnb-Benachrichtigungen weiterleiten</div><div style="font-size:13px;color:#a1a1aa">Richte in deinem E-Mail-Programm eine automatische Weiterleitung f√ºr Airbnb-Mails ein.</div></div>
            </div>
            <div style="display:flex;gap:12px;align-items:flex-start">
              <div style="background:#f97316;color:#fff;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;flex-shrink:0">3</div>
              <div><div style="font-weight:600">Bewertungen automatisch erhalten</div><div style="font-size:13px;color:#a1a1aa">Neue Bewertungen erscheinen automatisch hier - mit KI-Antwortvorschl√§gen!</div></div>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  
  return `
    <div class="stats-grid" style="grid-template-columns:repeat(4,1fr);margin-bottom:24px">
      <div class="stat-card">
        <div class="stat-value" style="color:#fbbf24">${avgRating}</div>
        <div class="stat-label">‚≠ê Durchschnitt</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${reviews.length}</div>
        <div class="stat-label">Bewertungen</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#f97316">${unverified}</div>
        <div class="stat-label">üìß Ungepr√ºft</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" style="color:#8b5cf6">${pending}</div>
        <div class="stat-label">üß† Ohne Antwort</div>
      </div>
    </div>
    
    <!-- Action Bar -->
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;flex-wrap:wrap;gap:12px">
      <div style="display:flex;gap:8px">
        <button class="btn btn-sm ${activeTab === 'all' ? 'btn-primary' : 'btn-secondary'}" onclick="setReviewsTab('all')">Alle (${reviews.length})</button>
        <button class="btn btn-sm ${activeTab === 'unverified' ? 'btn-primary' : 'btn-secondary'}" onclick="setReviewsTab('unverified')">${unverified > 0 ? 'üî¥ ' : ''}Ungepr√ºft (${unverified})</button>
        <button class="btn btn-sm ${activeTab === 'pending' ? 'btn-primary' : 'btn-secondary'}" onclick="setReviewsTab('pending')">Ohne Antwort (${pending})</button>
      </div>
      <div style="display:flex;gap:8px">
        <button class="btn btn-sm btn-secondary" onclick="showEmailSetupModal()">üìß Import-Setup</button>
        <button class="btn btn-sm btn-secondary" onclick="showAddReviewModal()">‚ûï Manuell</button>
        ${pending > 0 && aiEnabled ? '<button class="btn btn-sm btn-ai" onclick="generateAllAiSuggestions()">‚ú® Alle KI-Antworten</button>' : ''}
      </div>
    </div>
    
    <!-- Unverified hint -->
    ${unverified > 0 ? `
      <div class="card" style="background:#f9731610;border-color:#f9731650;margin-bottom:20px">
        <div style="display:flex;align-items:center;gap:12px">
          <div style="font-size:24px">üìß</div>
          <div style="flex:1">
            <div style="font-weight:600">${unverified} neue Bewertung${unverified > 1 ? 'en' : ''} aus E-Mail-Import</div>
            <div style="font-size:12px;color:#a1a1aa">Bitte √ºberpr√ºfe die extrahierten Daten und best√§tige sie.</div>
          </div>
          <button class="btn btn-sm btn-primary" onclick="setReviewsTab('unverified')">Jetzt pr√ºfen</button>
        </div>
      </div>
    ` : ''}
    
    <!-- Reviews List -->
    ${filteredReviews.map(r => {
      const isUnverified = r.status === 'unverified';
      const confidencePercent = Math.round((r.confidence || 0) * 100);
      const confidenceColor = confidencePercent >= 70 ? '#22c55e' : confidencePercent >= 40 ? '#f97316' : '#ef4444';
      const displayRating = r.rating || 0;
      
      return `
        <div class="review-card" style="${isUnverified ? 'border-left:3px solid #f97316' : ''}">
          <!-- Unverified Banner -->
          ${isUnverified ? `
            <div style="background:#f9731620;padding:8px 12px;margin:-20px -20px 16px -20px;border-radius:14px 14px 0 0;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px">
              <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                <span style="font-size:12px;font-weight:600;color:#f97316">üìß Aus E-Mail importiert</span>
                <span style="font-size:11px;color:#a1a1aa">Konfidenz: <span style="color:${confidenceColor}">${confidencePercent}%</span></span>
                ${r.parsing_strategy ? `<span style="font-size:10px;color:#71717a;background:#27272a;padding:2px 6px;border-radius:4px">${r.parsing_strategy}</span>` : ''}
              </div>
              <div style="display:flex;gap:6px">
                <button class="btn btn-sm" style="background:#22c55e;color:#fff;padding:4px 10px;font-size:11px" onclick="confirmReview('${r.id}')">‚úì Best√§tigen</button>
                <button class="btn btn-sm btn-secondary" style="padding:4px 10px;font-size:11px" onclick="editReviewData('${r.id}')">‚úèÔ∏è Bearbeiten</button>
              </div>
            </div>
          ` : ''}
          
          <!-- Header -->
          <div class="review-header">
            <div class="review-avatar">${r.guest ? r.guest.split(' ').map(n => n[0]).join('') : '?'}</div>
            <div class="review-info">
              <div class="review-name">${r.guest || r.guest_name || '<span style="color:#71717a">Unbekannter Gast</span>'}</div>
              <div class="review-meta">
                ${r.property || r.airbnb_listing_name || `<span style="color:#f97316;cursor:pointer" onclick="assignProperty('${r.id}')">+ Objekt zuweisen</span>`}
                ¬∑ ${r.date || (r.review_date ? new Date(r.review_date).toLocaleDateString('de-DE') : 'Datum unbekannt')}
                ${r.platform ? `¬∑ <span class="tag tag-${r.platform === 'airbnb' || r.platform === 'airbnb_email' ? 'red' : 'blue'}" style="font-size:9px">${r.platform === 'airbnb_email' ? 'Airbnb' : r.platform}</span>` : ''}
              </div>
            </div>
            <div class="review-stars">
              ${displayRating > 0 ? '‚òÖ'.repeat(displayRating) + '‚òÜ'.repeat(5 - displayRating) : '<span style="color:#71717a;font-size:12px">Keine Sterne</span>'}
            </div>
          </div>
          
          <!-- Review Text -->
          <div class="review-text">${r.text || r.review_text || ''}</div>
          
          <!-- Airbnb Link if available -->
          ${r.airbnb_review_url ? `<div style="margin-top:8px"><a href="${r.airbnb_review_url}" target="_blank" style="font-size:12px;color:#f97316">üîó In Airbnb √∂ffnen</a></div>` : ''}
          
          <!-- Reply Section -->
          ${r.replied ? `
            <div class="review-reply">
              <div class="review-reply-label">‚úì Deine Antwort:</div>
              <div style="font-size:14px">${r.reply || r.user_reply_text || ''}</div>
            </div>
          ` : (aiEnabled ? `
            <div class="ai-suggestion">
              <div class="ai-suggestion-header">üß† KI-Antwortvorschlag</div>
              <div class="ai-suggestion-text">${r.aiSuggestion || r.ai_reply_text || 'Klicke auf "Generieren" um einen KI-Vorschlag zu erhalten'}</div>
              <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:12px">
                ${r.aiSuggestion || r.ai_reply_text ? `<button class="btn btn-ai btn-sm" onclick="useAiReplyWithCopy('${r.id}')">üìã Kopieren & Verwenden</button>` : ''}
                <button class="btn btn-secondary btn-sm" onclick="regenAiReply('${r.id}')">${r.aiSuggestion || r.ai_reply_text ? 'üîÑ Neu' : '‚ú® Generieren'}</button>
                <button class="btn btn-secondary btn-sm" onclick="editReply('${r.id}')">‚úèÔ∏è Manuell</button>
                <button class="btn btn-sm" style="background:linear-gradient(135deg,#ff5a5f,#ff8c8c);color:#fff" onclick="openAirbnbToReply('${r.id}')">
                  <span style="margin-right:4px">üè†</span> Auf Airbnb antworten
                </button>
              </div>
            </div>
          ` : `
            <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn btn-secondary btn-sm" onclick="editReply('${r.id}')">‚úèÔ∏è Antwort schreiben</button>
              <button class="btn btn-sm" style="background:linear-gradient(135deg,#ff5a5f,#ff8c8c);color:#fff" onclick="openAirbnbToReply('${r.id}')">
                <span style="margin-right:4px">üè†</span> Auf Airbnb antworten
              </button>
            </div>
          `)}
        </div>
      `;
    }).join('')}
  `;
}

// Enhanced useAiReply with clipboard
function useAiReplyWithCopy(id) {
  const review = reviews.find(r => String(r.id) === String(id));
  if (!review) return;
  
  const replyText = review.aiSuggestion || review.ai_reply_text;
  if (!replyText) {
    showToast('‚ö†Ô∏è Kein KI-Vorschlag vorhanden');
    return;
  }
  
  // Copy to clipboard
  navigator.clipboard.writeText(replyText).then(() => {
    review.replied = true;
    review.reply = replyText;
    review.user_reply_text = replyText;
    review.replied_at = new Date().toISOString();
    
    showToast('‚úÖ Antwort in Zwischenablage kopiert!');
    
    // Show option to open Airbnb
    if (review.airbnb_review_url) {
      setTimeout(() => {
        if (confirm('Antwort kopiert! M√∂chtest du Airbnb √∂ffnen um die Antwort einzuf√ºgen?')) {
          window.open(review.airbnb_review_url, '_blank');
        }
      }, 500);
    }
    
    renderPage();
  }).catch(() => {
    // Fallback for older browsers
    const textarea = document.createElement('textarea');
    textarea.value = replyText;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
    
    review.replied = true;
    review.reply = replyText;
    showToast('‚úÖ Antwort kopiert!');
    renderPage();
  });
}

// Open Airbnb to reply - copies text first, then opens Airbnb
function openAirbnbToReply(id) {
  const review = reviews.find(r => String(r.id) === String(id));
  if (!review) return;
  
  const replyText = review.aiSuggestion || review.ai_reply_text || '';
  
  // Determine the best Airbnb URL
  let airbnbUrl;
  if (review.airbnb_review_url) {
    // Direct link to specific review
    airbnbUrl = review.airbnb_review_url;
  } else {
    // Fallback to general reviews page
    airbnbUrl = 'https://www.airbnb.com/hosting/reviews';
  }
  
  // If we have a reply text, copy it first
  if (replyText) {
    navigator.clipboard.writeText(replyText).then(() => {
      showToast('‚úÖ Antwort kopiert! Airbnb √∂ffnet sich...');
      
      // Mark as in-progress
      review.replied = true;
      review.reply = replyText;
      review.replied_at = new Date().toISOString();
      renderPage();
      
      // Open Airbnb after short delay
      setTimeout(() => {
        window.open(airbnbUrl, '_blank');
      }, 800);
      
    }).catch(() => {
      // Fallback copy
      const textarea = document.createElement('textarea');
      textarea.value = replyText;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      
      showToast('‚úÖ Antwort kopiert!');
      window.open(airbnbUrl, '_blank');
    });
  } else {
    // No reply text yet - show modal to generate or write one first
    showModal(`
      <div class="modal-title">üè† Auf Airbnb antworten</div>
      <div style="text-align:center;padding:20px 0">
        <div style="font-size:48px;margin-bottom:16px">‚úçÔ∏è</div>
        <div style="color:#a1a1aa;margin-bottom:24px;line-height:1.6">
          Du hast noch keine Antwort vorbereitet.<br>
          M√∂chtest du zuerst eine KI-Antwort generieren?
        </div>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
          <button class="btn btn-ai" onclick="hideModal();regenAiReply('${id}')">
            ‚ú® KI-Antwort generieren
          </button>
          <button class="btn btn-secondary" onclick="hideModal();window.open('${airbnbUrl}','_blank')">
            Trotzdem √∂ffnen ‚Üí
          </button>
        </div>
      </div>
    `);
  }
}

// Quick reply workflow: Generate AI reply and open Airbnb in one click
async function quickReplyToAirbnb(id) {
  const review = reviews.find(r => String(r.id) === String(id));
  if (!review) return;
  
  showToast('ü§ñ Generiere Antwort...');
  
  // Generate AI reply first
  await regenAiReply(id);
  
  // Wait for generation, then trigger Airbnb open
  setTimeout(() => {
    openAirbnbToReply(id);
  }, 2000);
}

function useAiReply(id) {
  const review = reviews.find(r => r.id === id);
  if (review) {
    review.replied = true;
    review.reply = review.aiSuggestion;
    showToast('‚úÖ Antwort ver√∂ffentlicht!');
    renderPage();
  }
}

async function regenAiReply(id) {
  const review = reviews.find(r => r.id === id);
  if (!review) return;
  
  // Show loading state
  review.aiSuggestion = 'ü§ñ Generiere neue Antwort...';
  renderPage();
  
  try {
    const session = await db.auth.getSession();
    const token = session?.data?.session?.access_token || '';
    
    const response = await fetch(AI_PROXY_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + token
      },
      body: JSON.stringify({
        action: 'review-reply',
        data: {
          guestName: review.guest,
          rating: review.rating,
          reviewText: review.text,
          propertyName: review.property
        }
      })
    });
    
    if (!response.ok) throw new Error('AI request failed');
    
    const data = await response.json();
    review.aiSuggestion = data.reply || 'Fehler bei der Generierung';
    
    showToast('‚úÖ Neue Antwort generiert!');
    
  } catch (error) {
    console.error('AI Review Reply Error:', error);
    // Fallback
    const alternatives = [
      'Herzlichen Dank f√ºr Ihre tolle Bewertung! Es freut mich sehr, dass Sie zufrieden waren. Ich hoffe, Sie bald wieder begr√º√üen zu d√ºrfen!',
      'Wow, vielen Dank f√ºr das gro√üartige Feedback! G√§ste wie Sie machen die Vermietung zu einer Freude. Bis zum n√§chsten Mal! üôè',
      'Danke f√ºr die lieben Worte! Es war mir eine Freude, Sie als Gast zu haben. Kommen Sie gerne wieder!'
    ];
    review.aiSuggestion = alternatives[Math.floor(Math.random() * alternatives.length)];
    showToast('‚ö†Ô∏è Fallback-Antwort verwendet');
  }
  
  renderPage();
}

// Generate AI suggestions for all unanswered reviews
async function generateAllAiSuggestions() {
  const unanswered = reviews.filter(r => !r.replied);
  if (unanswered.length === 0) {
    showToast('‚úÖ Alle Bewertungen sind bereits beantwortet!');
    return;
  }
  
  showToast(`ü§ñ Generiere ${unanswered.length} Antworten...`);
  
  const session = await db.auth.getSession();
  const token = session?.data?.session?.access_token || '';
  
  for (const review of unanswered) {
    try {
      const response = await fetch(AI_PROXY_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
          action: 'review-reply',
          data: {
            guestName: review.guest,
            rating: review.rating,
            reviewText: review.text,
            propertyName: review.property
          }
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        review.aiSuggestion = data.reply;
      }
    } catch (error) {
      console.error('Error generating reply for review', review.id, error);
    }
    
    // Small delay between requests
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  showToast('‚úÖ Alle Antworten generiert!');
  renderPage();
}

function editReply(id) {
  const review = reviews.find(r => r.id === id);
  showModal(`
    <div class="modal-title">‚úèÔ∏è Antwort bearbeiten</div>
    <div style="margin-bottom:16px">
      <label class="label">Deine Antwort</label>
      <textarea class="input" id="reply-text" rows="4" style="resize:vertical">${review.aiSuggestion}</textarea>
    </div>
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
      <button class="btn btn-primary" onclick="saveReply(${id})" style="flex:1">üíæ Speichern</button>
    </div>
  `);
}

function saveReply(id) {
  const review = reviews.find(r => r.id === id);
  const text = document.getElementById('reply-text').value.trim();
  if (review && text) {
    review.replied = true;
    review.reply = text;
    hideModal();
    renderPage();
  }
}

// Show modal to manually add a review
function showAddReviewModal() {
  const propertyOptions = properties.map(p => 
    `<option value="${p.name}">${p.name}</option>`
  ).join('');
  
  showModal(`
    <div class="modal-title">‚ûï Bewertung hinzuf√ºgen</div>
    <div style="margin-bottom:12px">
      <label class="label">Gast Name</label>
      <input type="text" class="input" id="review-guest" placeholder="z.B. Maria Schmidt">
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Objekt</label>
      <select class="input" id="review-property">
        ${propertyOptions || '<option value="">Kein Objekt</option>'}
      </select>
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Bewertung</label>
      <select class="input" id="review-rating">
        <option value="5">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (5 Sterne)</option>
        <option value="4">‚≠ê‚≠ê‚≠ê‚≠ê (4 Sterne)</option>
        <option value="3">‚≠ê‚≠ê‚≠ê (3 Sterne)</option>
        <option value="2">‚≠ê‚≠ê (2 Sterne)</option>
        <option value="1">‚≠ê (1 Stern)</option>
      </select>
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Bewertungstext</label>
      <textarea class="input" id="review-text" rows="4" placeholder="Text der Bewertung..."></textarea>
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Plattform</label>
      <select class="input" id="review-platform">
        <option value="airbnb">Airbnb</option>
        <option value="booking">Booking.com</option>
        <option value="google">Google</option>
        <option value="direct">Direkt</option>
      </select>
    </div>
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
      <button class="btn btn-primary" onclick="addReview()" style="flex:1">‚ûï Hinzuf√ºgen</button>
    </div>
  `);
}

// Add a new review manually
async function addReview() {
  const guest = document.getElementById('review-guest').value.trim();
  const property = document.getElementById('review-property').value;
  const rating = parseInt(document.getElementById('review-rating').value);
  const text = document.getElementById('review-text').value.trim();
  const platform = document.getElementById('review-platform').value;
  
  if (!guest || !text) {
    showToast('‚ö†Ô∏è Bitte Gast und Text eingeben');
    return;
  }
  
  // Create new review
  const newReview = {
    id: Date.now(),
    guest: guest,
    property: property || 'Unbekannt',
    rating: rating,
    text: text,
    platform: platform,
    date: new Date().toLocaleDateString('de-DE'),
    replied: false,
    aiSuggestion: null
  };
  
  // Add to reviews array
  reviews.unshift(newReview);
  
  // Save to Supabase (if reviews table exists)
  try {
    await db.from('reviews').insert({
      host_id: user.id,
      guest_name: guest,
      property_name: property,
      rating: rating,
      review_text: text,
      platform: platform,
      replied: false
    });
  } catch (e) {
    console.log('Could not save review to DB (table may not exist):', e);
  }
  
  hideModal();
  showToast('‚úÖ Bewertung hinzugef√ºgt!');
  renderPage();
  
  // If AI reviews enabled, generate suggestion
  if (automationSettings.reviewReplies) {
    setTimeout(() => regenAiReply(newReview.id), 500);
  }
}

// =====================
// EMAIL IMPORT FUNCTIONS
// =====================

// Set reviews tab filter
function setReviewsTab(tab) {
  window.reviewsActiveTab = tab;
  renderPage();
}

// Confirm an unverified review
async function confirmReview(id) {
  const review = reviews.find(r => String(r.id) === String(id));
  if (!review) return;
  
  review.status = 'confirmed';
  showToast('‚úÖ Bewertung best√§tigt!');
  
  // Save to database if connected
  if (user && db) {
    try {
      await db.from('reviews').update({ status: 'confirmed', updated_at: new Date().toISOString() }).eq('id', id);
    } catch (e) {
      console.error('Failed to update review status:', e);
    }
  }
  
  renderPage();
}

// Edit review data modal
function editReviewData(id) {
  const review = reviews.find(r => String(r.id) === String(id));
  if (!review) return;
  
  const propertyOptions = properties.map(p => {
    const selected = (review.property_id === p.id || review.property === p.name) ? 'selected' : '';
    return `<option value="${p.id}" ${selected}>${p.name}</option>`;
  }).join('');
  
  showModal(`
    <div class="modal-title">‚úèÔ∏è Bewertung bearbeiten</div>
    <div style="background:#27272a;padding:12px;border-radius:8px;margin-bottom:16px;font-size:12px;color:#a1a1aa">
      üìß Importiert mit Konfidenz: ${Math.round((review.confidence || 0) * 100)}%
      ${review.parsing_notes ? '<br>Notizen: ' + review.parsing_notes : ''}
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Gast Name</label>
      <input type="text" class="input" id="edit-guest" value="${review.guest || review.guest_name || ''}" placeholder="Name des Gastes">
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Objekt</label>
      <select class="input" id="edit-property">
        <option value="">-- Objekt ausw√§hlen --</option>
        ${propertyOptions}
      </select>
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Bewertung (Sterne)</label>
      <select class="input" id="edit-rating">
        <option value="">Unbekannt</option>
        <option value="5" ${review.rating === 5 ? 'selected' : ''}>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (5)</option>
        <option value="4" ${review.rating === 4 ? 'selected' : ''}>‚≠ê‚≠ê‚≠ê‚≠ê (4)</option>
        <option value="3" ${review.rating === 3 ? 'selected' : ''}>‚≠ê‚≠ê‚≠ê (3)</option>
        <option value="2" ${review.rating === 2 ? 'selected' : ''}>‚≠ê‚≠ê (2)</option>
        <option value="1" ${review.rating === 1 ? 'selected' : ''}>‚≠ê (1)</option>
      </select>
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Datum</label>
      <input type="date" class="input" id="edit-date" value="${review.review_date || ''}">
    </div>
    <div style="margin-bottom:12px">
      <label class="label">Bewertungstext</label>
      <textarea class="input" id="edit-text" rows="4">${review.text || review.review_text || ''}</textarea>
    </div>
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
      <button class="btn btn-primary" onclick="saveReviewData('${id}')" style="flex:1">üíæ Speichern & Best√§tigen</button>
    </div>
  `);
}

// Save edited review data
async function saveReviewData(id) {
  const review = reviews.find(r => String(r.id) === String(id));
  if (!review) return;
  
  const guest = document.getElementById('edit-guest').value.trim();
  const propertyId = document.getElementById('edit-property').value;
  const rating = document.getElementById('edit-rating').value;
  const date = document.getElementById('edit-date').value;
  const text = document.getElementById('edit-text').value.trim();
  
  // Update local
  review.guest = guest || review.guest;
  review.guest_name = guest || review.guest_name;
  if (propertyId) {
    review.property_id = propertyId;
    const prop = properties.find(p => p.id === propertyId);
    if (prop) review.property = prop.name;
  }
  review.rating = rating ? parseInt(rating) : review.rating;
  review.review_date = date || review.review_date;
  review.text = text || review.text;
  review.review_text = text || review.review_text;
  review.status = 'manual';
  
  // Save to database
  if (user && db) {
    try {
      await db.from('reviews').update({
        guest_name: review.guest_name,
        property_id: review.property_id,
        rating: review.rating,
        review_date: review.review_date,
        review_text: review.review_text,
        status: 'manual',
        updated_at: new Date().toISOString()
      }).eq('id', id);
    } catch (e) {
      console.error('Failed to save review:', e);
    }
  }
  
  hideModal();
  showToast('‚úÖ Bewertung gespeichert!');
  renderPage();
}

// Assign property to review
function assignProperty(id) {
  editReviewData(id);
}

// Show email setup modal
function showEmailSetupModal() {
  // Generate or get forwarding email
  let forwardingEmail = localStorage.getItem('pilotstay_forwarding_email');
  if (!forwardingEmail) {
    forwardingEmail = 'review-' + Math.random().toString(36).substr(2, 8) + '@reviews.pilotstay.app';
    localStorage.setItem('pilotstay_forwarding_email', forwardingEmail);
  }
  
  showModal(`
    <div class="modal-title">üìß E-Mail-Import einrichten</div>
    
    <div style="background:linear-gradient(135deg,#131316,#1a1a2e);border:1px solid #8b5cf650;border-radius:12px;padding:20px;margin-bottom:20px">
      <div style="font-size:12px;color:#a1a1aa;margin-bottom:8px">Deine pers√∂nliche Weiterleitungsadresse:</div>
      <div style="display:flex;gap:8px;align-items:center">
        <input type="text" class="input" id="forwarding-email" value="${forwardingEmail}" readonly style="flex:1;font-family:monospace;font-size:13px">
        <button class="btn btn-primary" onclick="copyForwardingEmail()">üìã Kopieren</button>
      </div>
    </div>
    
    <div style="margin-bottom:20px">
      <div style="font-weight:600;margin-bottom:12px">üìã Einrichtung in 3 Schritten:</div>
      
      <div style="background:#27272a;border-radius:8px;padding:16px;margin-bottom:12px">
        <div style="font-weight:600;margin-bottom:8px">1Ô∏è‚É£ Gmail Weiterleitung</div>
        <div style="font-size:13px;color:#a1a1aa;line-height:1.5">
          ‚Ä¢ √ñffne Gmail ‚Üí Einstellungen ‚Üí "Weiterleitung und POP/IMAP"<br>
          ‚Ä¢ Klicke "Weiterleitungsadresse hinzuf√ºgen"<br>
          ‚Ä¢ F√ºge deine PilotStay-Adresse ein<br>
          ‚Ä¢ Erstelle einen Filter: von "airbnb" ‚Üí weiterleiten
        </div>
      </div>
      
      <div style="background:#27272a;border-radius:8px;padding:16px;margin-bottom:12px">
        <div style="font-weight:600;margin-bottom:8px">2Ô∏è‚É£ Outlook/Mail Weiterleitung</div>
        <div style="font-size:13px;color:#a1a1aa;line-height:1.5">
          ‚Ä¢ Einstellungen ‚Üí Regeln ‚Üí Neue Regel<br>
          ‚Ä¢ Bedingung: Absender enth√§lt "airbnb"<br>
          ‚Ä¢ Aktion: Weiterleiten an PilotStay-Adresse
        </div>
      </div>
      
      <div style="background:#27272a;border-radius:8px;padding:16px">
        <div style="font-weight:600;margin-bottom:8px">3Ô∏è‚É£ Test senden</div>
        <div style="font-size:13px;color:#a1a1aa;line-height:1.5">
          Leite eine bestehende Airbnb-Bewertungs-E-Mail weiter um zu testen.
        </div>
      </div>
    </div>
    
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Schlie√üen</button>
      <button class="btn btn-primary" onclick="testEmailImport()" style="flex:1">üß™ Test-Import</button>
    </div>
  `);
}

// Copy forwarding email
function copyForwardingEmail() {
  const input = document.getElementById('forwarding-email');
  input.select();
  document.execCommand('copy');
  showToast('‚úÖ E-Mail-Adresse kopiert!');
}

// Test email import with sample data
async function testEmailImport() {
  showToast('üß™ Importiere Test-Bewertung...');
  hideModal();
  
  // Create a test review locally
  const testReview = {
    id: 'test_' + Date.now(),
    guest: 'Maria Testgast',
    guest_name: 'Maria Testgast',
    property: properties.length > 0 ? properties[0].name : 'Test-Apartment',
    property_id: properties.length > 0 ? properties[0].id : null,
    rating: 5,
    text: 'Wundersch√∂ne Unterkunft! Alles war super sauber und der Gastgeber hat uns sehr herzlich empfangen. Die Lage ist perfekt - direkt in der Innenstadt mit vielen Restaurants und Caf√©s in der N√§he. Wir kommen definitiv wieder!',
    review_text: 'Wundersch√∂ne Unterkunft! Alles war super sauber...',
    platform: 'airbnb_email',
    date: new Date().toLocaleDateString('de-DE'),
    review_date: new Date().toISOString().split('T')[0],
    status: 'unverified',
    confidence: 0.85,
    parsing_strategy: 'test_import',
    parsing_notes: 'Test-Import zur Demonstration',
    airbnb_listing_name: properties.length > 0 ? properties[0].name : null,
    replied: false,
    aiSuggestion: null
  };
  
  reviews.unshift(testReview);
  
  setTimeout(() => {
    showToast('‚úÖ Test-Bewertung importiert! Bitte √ºberpr√ºfen.');
    window.reviewsActiveTab = 'unverified';
    renderPage();
  }, 1000);
}

// Load reviews from database (including email-imported ones)
async function loadReviewsFromDB() {
  if (!user || !db) return;
  
  try {
    const { data, error } = await db
      .from('reviews')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('Error loading reviews:', error);
      return;
    }
    
    if (data && data.length > 0) {
      // Merge with existing reviews
      data.forEach(dbReview => {
        const exists = reviews.find(r => r.id === dbReview.id);
        if (!exists) {
          reviews.push({
            id: dbReview.id,
            guest: dbReview.guest_name,
            guest_name: dbReview.guest_name,
            property: dbReview.property_id ? (properties.find(p => p.id === dbReview.property_id)?.name || 'Unbekannt') : dbReview.airbnb_listing_name,
            property_id: dbReview.property_id,
            rating: dbReview.rating,
            text: dbReview.review_text,
            review_text: dbReview.review_text,
            platform: dbReview.platform,
            date: dbReview.review_date ? new Date(dbReview.review_date).toLocaleDateString('de-DE') : null,
            review_date: dbReview.review_date,
            status: dbReview.status,
            confidence: dbReview.confidence,
            parsing_strategy: dbReview.parsing_strategy,
            parsing_notes: dbReview.parsing_notes,
            airbnb_listing_name: dbReview.airbnb_listing_name,
            airbnb_review_url: dbReview.airbnb_review_url,
            replied: !!dbReview.replied_at,
            reply: dbReview.user_reply_text,
            aiSuggestion: dbReview.ai_reply_text,
            ai_reply_text: dbReview.ai_reply_text
          });
        }
      });
      
      console.log(`Loaded ${data.length} reviews from database`);
    }
  } catch (e) {
    console.error('Error in loadReviewsFromDB:', e);
  }
}

// =====================
// PRICING (AI)
// =====================
function renderPricing() {
  const dayNames = ['So','Mo','Di','Mi','Do','Fr','Sa'];
  const aiEnabled = automationSettings.autoPricing;
  
  // Check if there are any properties
  if (pricingData.properties.length === 0) {
    return `
      <div class="empty-state" style="padding:60px 20px">
        <div class="empty-icon">üí∞</div>
        <div class="empty-title">Keine Objekte f√ºr Preisoptimierung</div>
        <div class="empty-desc" style="margin-bottom:20px">
          ${properties.length === 0 
            ? 'F√ºge zuerst Objekte hinzu oder verbinde Smoobu um die Preisoptimierung zu nutzen.' 
            : 'Synchronisiere deine Smoobu-Daten um Preise zu optimieren.'}
        </div>
        <div style="display:flex;gap:12px;justify-content:center">
          ${properties.length === 0 
            ? '<button class="btn btn-primary" onclick="setPage(\'properties\')">üè† Objekte hinzuf√ºgen</button>'
            : '<button class="btn btn-primary" onclick="setPage(\'automation\')">üîÑ Smoobu verbinden</button>'}
        </div>
      </div>
    `;
  }
  
  // Count events found
  const eventCount = pricingData.events?.length || 0;
  
  return `
    ${!aiEnabled ? `
      <div class="card" style="background:#f9731610;border-color:#f9731650;margin-bottom:20px">
        <div style="display:flex;align-items:center;gap:12px">
          <div style="font-size:24px">‚ö†Ô∏è</div>
          <div style="flex:1">
            <div style="font-weight:600">Auto-Pricing deaktiviert</div>
            <div style="font-size:12px;color:#a1a1aa">Preise werden nicht automatisch optimiert</div>
          </div>
          <button class="btn btn-sm btn-primary" onclick="toggleAutomation('autoPricing');setPage('pricing')">Aktivieren</button>
        </div>
      </div>
    ` : `
      <div class="card card-ai" style="margin-bottom:24px">
        <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap">
          <div style="font-size:48px">üß†</div>
          <div style="flex:1;min-width:200px">
            <div style="font-weight:700;font-size:18px;margin-bottom:4px">KI-Preisoptimierung aktiv</div>
            <div style="color:#a1a1aa;font-size:13px">Tagesbasierte Preise mit Event-Erkennung</div>
          </div>
          <div style="display:flex;gap:16px;flex-wrap:wrap">
            <div style="text-align:center;padding:8px 16px;background:#22c55e15;border-radius:8px">
              <div style="font-size:20px;font-weight:700;color:#22c55e">${eventCount}</div>
              <div style="font-size:10px;color:#71717a">Events erkannt</div>
            </div>
            <div style="text-align:center;padding:8px 16px;background:#8b5cf615;border-radius:8px">
              <div style="font-size:20px;font-weight:700;color:#8b5cf6">60</div>
              <div style="font-size:10px;color:#71717a">Tage optimiert</div>
            </div>
          </div>
        </div>
      </div>
    `}
    
    ${pricingData.properties.map(prop => {
      const dailyPrices = pricingData.dailyPrices[prop.id] || [];
      const next30Days = dailyPrices.slice(0, 30);
      const avgChange = next30Days.length ? Math.round(next30Days.reduce((s, d) => s + d.changePercent, 0) / next30Days.length) : 0;
      const eventsInPeriod = next30Days.filter(d => d.events.length > 0).length;
      const notApplied = next30Days.filter(d => !d.applied && !d.isBooked).length;
      
      return `
        <div class="pricing-card" style="margin-bottom:24px">
          <div class="pricing-header" style="margin-bottom:16px">
            <div>
              <div class="pricing-property">${prop.name}</div>
              <div style="font-size:12px;color:#71717a">${prop.city || 'Keine Stadt'} ¬∑ Basispreis: ‚Ç¨${prop.basePrice}/Nacht</div>
            </div>
            <div style="text-align:right">
              <div style="font-size:12px;color:#71717a">Durchschn. Anpassung</div>
              <div style="font-size:24px;font-weight:700;color:${avgChange >= 0 ? '#22c55e' : '#ef4444'}">${avgChange >= 0 ? '+' : ''}${avgChange}%</div>
            </div>
          </div>
          
          <!-- Stats Row -->
          <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:20px">
            <div style="background:#18181b;padding:12px;border-radius:8px;text-align:center">
              <div style="font-size:18px;font-weight:700">${prop.occupancy}%</div>
              <div style="font-size:10px;color:#71717a">Auslastung</div>
            </div>
            <div style="background:#18181b;padding:12px;border-radius:8px;text-align:center">
              <div style="font-size:18px;font-weight:700;color:#f97316">${eventsInPeriod}</div>
              <div style="font-size:10px;color:#71717a">Event-Tage</div>
            </div>
            <div style="background:#18181b;padding:12px;border-radius:8px;text-align:center">
              <div style="font-size:18px;font-weight:700;color:#8b5cf6">${notApplied}</div>
              <div style="font-size:10px;color:#71717a">Zu √ºbertragen</div>
            </div>
            <div style="background:#18181b;padding:12px;border-radius:8px;text-align:center">
              ${notApplied > 0 ? `
                <button class="btn btn-sm btn-primary" onclick="applyAllDailyPrices('${prop.id}')" style="width:100%" ${!smoobuConfig.connected ? 'disabled' : ''}>
                  ‚úì Alle √ºbernehmen
                </button>
              ` : `
                <button class="btn btn-sm btn-secondary" style="width:100%;cursor:default" disabled>
                  ‚úÖ Alle synchronisiert
                </button>
              `}
            </div>
          </div>
          
          <!-- Calendar Header -->
          <div style="font-size:13px;font-weight:600;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center">
            <span>üìÖ Preiskalender (n√§chste 30 Tage)</span>
            <span style="font-size:11px;color:#71717a">Klicke auf einen Tag f√ºr Details</span>
          </div>
          
          <!-- Calendar Grid -->
          <div style="display:grid;grid-template-columns:repeat(7,1fr);gap:4px;margin-bottom:16px">
            ${['Mo','Di','Mi','Do','Fr','Sa','So'].map(d => `
              <div style="text-align:center;font-size:10px;color:#71717a;padding:4px">${d}</div>
            `).join('')}
            
            ${(() => {
              // Find first day offset
              const firstDate = next30Days[0] ? new Date(next30Days[0].date) : new Date();
              let startDay = firstDate.getDay();
              startDay = startDay === 0 ? 6 : startDay - 1; // Convert to Monday-start
              
              let html = '';
              // Add empty cells for offset
              for (let i = 0; i < startDay; i++) {
                html += '<div></div>';
              }
              
              // Add day cells
              next30Days.forEach((day, idx) => {
                const date = new Date(day.date);
                const dayNum = date.getDate();
                const hasEvent = day.events.length > 0;
                const isHoliday = day.factors.some(f => f.type === 'holiday');
                const isWeekend = day.dayOfWeek === 0 || day.dayOfWeek === 5 || day.dayOfWeek === 6;
                
                let bgColor = '#18181b';
                let borderColor = 'transparent';
                
                if (day.isBooked) {
                  bgColor = '#27272a';
                  borderColor = '#3f3f46';
                } else if (hasEvent) {
                  bgColor = '#f9731620';
                  borderColor = '#f97316';
                } else if (isHoliday) {
                  bgColor = '#8b5cf620';
                  borderColor = '#8b5cf6';
                } else if (day.changePercent > 10) {
                  bgColor = '#22c55e15';
                } else if (day.changePercent < -3) {
                  bgColor = '#ef444415';
                }
                
                html += `
                  <div onclick="showDayPriceDetail('${prop.id}', '${day.date}')" 
                       style="background:${bgColor};border:2px solid ${borderColor};border-radius:8px;padding:6px;text-align:center;cursor:pointer;transition:all .2s;${day.applied ? 'opacity:0.6' : ''}"
                       onmouseover="this.style.transform='scale(1.05)'" 
                       onmouseout="this.style.transform='scale(1)'">
                    <div style="font-size:11px;color:#a1a1aa">${dayNum}</div>
                    <div style="font-size:13px;font-weight:700;color:${day.changePercent > 0 ? '#22c55e' : day.changePercent < 0 ? '#ef4444' : '#fafafa'}">‚Ç¨${day.finalPrice}</div>
                    ${hasEvent ? '<div style="font-size:8px">üé≠</div>' : ''}
                    ${isHoliday ? '<div style="font-size:8px">üéâ</div>' : ''}
                    ${day.isBooked ? '<div style="font-size:8px">üîí</div>' : ''}
                    ${day.applied ? '<div style="font-size:8px">‚úì</div>' : ''}
                  </div>
                `;
              });
              
              return html;
            })()}
          </div>
          
          <!-- Legend -->
          <div style="display:flex;gap:16px;flex-wrap:wrap;font-size:11px;color:#71717a;padding:12px;background:#18181b;border-radius:8px">
            <span>üé≠ Event</span>
            <span>üéâ Feiertag</span>
            <span>üîí Gebucht</span>
            <span>‚úì √úbertragen</span>
            <span style="color:#22c55e">‚ñ† Erh√∂ht</span>
            <span style="color:#ef4444">‚ñ† Reduziert</span>
          </div>
        </div>
      `;
    }).join('')}
    
    <!-- Events Found Section -->
    ${pricingData.events.length > 0 ? `
      <div class="card">
        <div class="card-title">üé≠ Erkannte Events in deiner Region</div>
        <div style="max-height:300px;overflow-y:auto">
          ${pricingData.events.slice(0, 10).map(event => `
            <div class="list-item" style="margin-bottom:8px">
              <div class="list-icon">üé´</div>
              <div class="list-info">
                <div class="list-title">${event.name}</div>
                <div class="list-subtitle">
                  ${event.dates?.start?.localDate || ''} ¬∑ ${event._embedded?.venues?.[0]?.name || ''} ¬∑ ${event._embedded?.venues?.[0]?.city?.name || ''}
                </div>
              </div>
              <a href="${event.url}" target="_blank" class="btn btn-sm btn-secondary">‚Üó</a>
            </div>
          `).join('')}
        </div>
        ${pricingData.events.length > 10 ? `
          <div style="text-align:center;padding:12px;color:#71717a;font-size:12px">
            +${pricingData.events.length - 10} weitere Events
          </div>
        ` : ''}
      </div>
    ` : `
      <div class="card">
        <div class="card-title">üé≠ Events</div>
        <div style="text-align:center;padding:20px;color:#71717a">
          <div style="font-size:24px;margin-bottom:8px">üîç</div>
          <div style="font-size:13px">Events werden automatisch gesucht...</div>
          <div style="font-size:11px;margin-top:4px">Basierend auf den St√§dten deiner Objekte</div>
        </div>
      </div>
    `}
    
    <!-- Pricing Strategy -->
    <div class="card" style="margin-top:16px">
      <div class="card-title">‚öôÔ∏è Pricing-Strategie</div>
      <div class="grid-3" style="margin-bottom:16px">
        <div class="list-item" style="cursor:pointer;${pricingData.strategy==='conservative'?'border:2px solid #22c55e':''}" onclick="setPricingStrategy('conservative')">
          <div class="list-icon">üê¢</div>
          <div class="list-info">
            <div class="list-title">Konservativ</div>
            <div class="list-subtitle">Kleine Anpassungen, stabil</div>
          </div>
        </div>
        <div class="list-item" style="cursor:pointer;${pricingData.strategy==='balanced'?'border:2px solid #22c55e':''}" onclick="setPricingStrategy('balanced')">
          <div class="list-icon">‚öñÔ∏è</div>
          <div class="list-info">
            <div class="list-title">Ausgewogen</div>
            <div class="list-subtitle">Gute Balance</div>
          </div>
        </div>
        <div class="list-item" style="cursor:pointer;${pricingData.strategy==='aggressive'?'border:2px solid #22c55e':''}" onclick="setPricingStrategy('aggressive')">
          <div class="list-icon">üöÄ</div>
          <div class="list-info">
            <div class="list-title">Aggressiv</div>
            <div class="list-subtitle">Max. Umsatz</div>
          </div>
        </div>
      </div>
      <div style="padding:12px;background:#18181b;border-radius:10px;font-size:12px;color:#a1a1aa">
        üí° Strategie beeinflusst alle Preisanpassungen: Wochenenden, Feiertage, Events
      </div>
    </div>
  `;
}

// Show day price detail modal
function showDayPriceDetail(propertyId, dateStr) {
  const prop = pricingData.properties.find(p => p.id === propertyId);
  const dailyPrices = pricingData.dailyPrices[propertyId];
  const day = dailyPrices?.find(d => d.date === dateStr);
  
  if (!prop || !day) return;
  
  const date = new Date(dateStr);
  const dateFormatted = date.toLocaleDateString('de-DE', { weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
  
  showModal(`
    <div class="modal-title">üìÖ ${dateFormatted}</div>
    <div style="margin-bottom:20px">
      <div style="font-size:14px;color:#a1a1aa">${prop.name}</div>
    </div>
    
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:20px">
      <div style="background:#18181b;padding:16px;border-radius:10px;text-align:center">
        <div style="font-size:12px;color:#71717a">Basispreis</div>
        <div style="font-size:24px;font-weight:700">‚Ç¨${day.basePrice}</div>
      </div>
      <div style="background:${day.changePercent >= 0 ? '#22c55e15' : '#ef444415'};padding:16px;border-radius:10px;text-align:center">
        <div style="font-size:12px;color:#71717a">Optimierter Preis</div>
        <div style="font-size:24px;font-weight:700;color:${day.changePercent >= 0 ? '#22c55e' : '#ef4444'}">‚Ç¨${day.finalPrice}</div>
        <div style="font-size:12px;color:${day.changePercent >= 0 ? '#22c55e' : '#ef4444'}">${day.changePercent >= 0 ? '+' : ''}${day.changePercent}%</div>
      </div>
    </div>
    
    ${day.isBooked ? `
      <div style="background:#27272a;padding:16px;border-radius:10px;margin-bottom:20px;text-align:center">
        <div style="font-size:24px;margin-bottom:8px">üîí</div>
        <div style="color:#a1a1aa">Dieser Tag ist bereits gebucht</div>
      </div>
    ` : ''}
    
    ${day.factors.length > 0 ? `
      <div style="margin-bottom:20px">
        <div style="font-size:12px;color:#71717a;margin-bottom:8px">Preisfaktoren:</div>
        <div style="display:flex;flex-direction:column;gap:8px">
          ${day.factors.map(f => `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:10px;background:#18181b;border-radius:8px">
              <span style="font-size:13px">${f.label}</span>
              <span style="color:${f.boost >= 0 ? '#22c55e' : '#ef4444'};font-weight:600">${f.boost >= 0 ? '+' : ''}${Math.round(f.boost * 100)}%</span>
            </div>
          `).join('')}
        </div>
      </div>
    ` : ''}
    
    ${day.events.length > 0 ? `
      <div style="margin-bottom:20px">
        <div style="font-size:12px;color:#71717a;margin-bottom:8px">Events an diesem Tag:</div>
        ${day.events.map(e => `
          <div style="padding:12px;background:#f9731615;border:1px solid #f9731650;border-radius:8px;margin-bottom:8px">
            <div style="font-weight:600">${e.name}</div>
            <div style="font-size:12px;color:#a1a1aa">${e.venue}</div>
          </div>
        `).join('')}
      </div>
    ` : ''}
    
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Schlie√üen</button>
      ${!day.isBooked && smoobuConfig.connected ? `
        <button class="btn btn-primary" onclick="applySingleDayPrice('${propertyId}', '${dateStr}');hideModal()" style="flex:1" ${day.applied ? 'disabled' : ''}>
          ${day.applied ? '‚úì Bereits √ºbertragen' : '‚úì Preis √ºbernehmen'}
        </button>
      ` : ''}
    </div>
  `);
}

// Pricing Strategy Functions
async function setPricingStrategy(strategy) {
  pricingData.strategy = strategy;
  localStorage.setItem('pricing_strategy', strategy);
  
  // Save to Supabase
  saveAutomationSettings();
  
  // Recalculate all daily prices with new strategy
  await calculateAllDailyPrices();
  
  showToast(`‚úÖ Strategie auf "${strategy === 'conservative' ? 'Konservativ' : strategy === 'balanced' ? 'Ausgewogen' : 'Aggressiv'}" gesetzt`);
  renderPage();
}

// Load saved strategy on init - now handled by loadAutomationSettings
function loadPricingStrategy() {
  // This is now a backup - primary loading happens in loadAutomationSettings
  const saved = localStorage.getItem('pricing_strategy');
  if (saved && !pricingData.strategy) {
    pricingData.strategy = saved;
  }
}

async function applyPrice(propId, newPrice) {
  const prop = pricingData.properties.find(p => p.id === propId);
  if (!prop) return;
  
  // Check if Smoobu is connected and auto-pricing is enabled
  if (smoobuConfig.connected && automationSettings.autoPricing) {
    showModal(`
      <div style="text-align:center;padding:40px">
        <div class="spinner" style="margin:0 auto 20px"></div>
        <div style="font-size:16px;font-weight:600">Aktualisiere Preis...</div>
        <div style="color:#71717a;font-size:13px;margin-top:8px">Sende an Smoobu ‚Üí Airbnb/Booking</div>
      </div>
    `);
    
    try {
      // Get dates for the next 30 days
      const today = new Date();
      const dates = [];
      for (let i = 0; i < 30; i++) {
        const d = new Date(today);
        d.setDate(d.getDate() + i);
        dates.push(d.toISOString().split('T')[0]);
      }
      
      // Create date range string
      const startDate = dates[0];
      const endDate = dates[dates.length - 1];
      
      // Send to Smoobu via Edge Function
      const response = await fetch(`${SMOOBU_PROXY_URL}?action=update-rates`, {
        method: 'POST',
        headers: {
          'x-smoobu-key': smoobuConfig.apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          apartments: [propId],
          operations: [{
            dates: [`${startDate}:${endDate}`],
            daily_price: newPrice
          }]
        })
      });
      
      const result = await response.json();
      
      if (!response.ok || result.error) {
        throw new Error(result.error || 'Preis-Update fehlgeschlagen');
      }
      
      // Success - update local state
      prop.currentPrice = newPrice;
      
      hideModal();
      showToast(`‚úÖ Preis auf ‚Ç¨${newPrice} aktualisiert (Smoobu ‚Üí Airbnb/Booking)`);
      renderPage();
      
    } catch (error) {
      hideModal();
      console.error('Price update error:', error);
      showModal(`
        <div style="text-align:center;padding:20px">
          <div style="font-size:64px;margin-bottom:16px">‚ö†Ô∏è</div>
          <div style="font-size:18px;font-weight:700;margin-bottom:8px">Preis-Update fehlgeschlagen</div>
          <div style="color:#ef4444;margin-bottom:16px;font-size:13px">${error.message}</div>
          <div style="color:#71717a;font-size:12px;margin-bottom:24px">Der Preis wurde lokal aktualisiert, aber nicht zu Smoobu gesendet.</div>
          <button class="btn btn-secondary" onclick="hideModal()" style="width:100%">Schlie√üen</button>
        </div>
      `);
      
      // Still update locally
      prop.currentPrice = newPrice;
      renderPage();
    }
  } else {
    // No Smoobu connection - just update locally
    prop.currentPrice = newPrice;
    showToast(`üí∞ Preis lokal auf ‚Ç¨${newPrice} aktualisiert`);
    renderPage();
  }
}

// =====================
// OTHER PAGES
// =====================
function renderBookings() {
  // Separate active and cancelled bookings
  const activeBookings = bookings.filter(b => b.status !== 'cancelled');
  const cancelledBookings = bookings.filter(b => b.status === 'cancelled');
  
  if (!bookings.length) return '<div class="empty-state"><div class="empty-icon">üìÖ</div><div class="empty-title">Keine Buchungen</div><button class="btn btn-primary" onclick="showAddBook()">+ Buchung</button></div>';
  
  return `
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;flex-wrap:wrap;gap:12px">
        <div class="card-title" style="margin:0">üìÖ Aktive Buchungen (${activeBookings.length})</div>
        <div style="display:flex;gap:8px;align-items:center">
          ${cancelledBookings.length > 0 ? `
            <button class="btn btn-sm btn-secondary" onclick="toggleCancelledBookings()" id="toggle-cancelled-btn">
              ${window.showCancelledBookings ? 'üôà Stornierte ausblenden' : `üëÅÔ∏è ${cancelledBookings.length} Stornierte anzeigen`}
            </button>
          ` : ''}
          <button class="btn btn-sm btn-primary" onclick="showAddBook()">+ Neue Buchung</button>
        </div>
      </div>
      
      ${activeBookings.length > 0 ? `
        <table class="table">
          <thead>
            <tr>
              <th>Gast</th>
              <th>Objekt</th>
              <th>Check-in</th>
              <th>Check-out</th>
              <th>Betrag</th>
              <th>Status</th>
              <th style="width:100px">Aktionen</th>
            </tr>
          </thead>
          <tbody>
            ${activeBookings.map(b => `
              <tr>
                <td><strong>${b.guest_name}</strong></td>
                <td>${b.properties?.name || '-'}</td>
                <td>${fmtDate(b.check_in)}</td>
                <td>${fmtDate(b.check_out)}</td>
                <td><strong>‚Ç¨${b.total_price || 0}</strong></td>
                <td><span class="tag tag-green">Best√§tigt</span></td>
                <td>
                  <div style="display:flex;gap:4px">
                    <button class="btn btn-sm btn-secondary" onclick="editBooking('${b.id}')" title="Bearbeiten">‚úèÔ∏è</button>
                    <button class="btn btn-sm btn-secondary" onclick="deleteBooking('${b.id}')" title="L√∂schen" style="color:#ef4444">üóëÔ∏è</button>
                  </div>
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      ` : `
        <div class="empty-state" style="padding:30px">
          <div class="empty-icon">üì≠</div>
          <div class="empty-desc">Keine aktiven Buchungen</div>
        </div>
      `}
    </div>
    
    ${window.showCancelledBookings && cancelledBookings.length > 0 ? `
      <div class="card" style="margin-top:16px;opacity:0.7">
        <div class="card-title" style="color:#ef4444">üö´ Stornierte Buchungen (${cancelledBookings.length})</div>
        <table class="table">
          <thead>
            <tr>
              <th>Gast</th>
              <th>Objekt</th>
              <th>Check-in</th>
              <th>Check-out</th>
              <th>Betrag</th>
              <th>Status</th>
              <th style="width:100px">Aktionen</th>
            </tr>
          </thead>
          <tbody>
            ${cancelledBookings.map(b => `
              <tr style="opacity:0.6">
                <td><strong>${b.guest_name}</strong></td>
                <td>${b.properties?.name || '-'}</td>
                <td>${fmtDate(b.check_in)}</td>
                <td>${fmtDate(b.check_out)}</td>
                <td><strong style="text-decoration:line-through">‚Ç¨${b.total_price || 0}</strong></td>
                <td><span class="tag tag-red">Storniert</span></td>
                <td>
                  <div style="display:flex;gap:4px">
                    <button class="btn btn-sm btn-secondary" onclick="deleteBooking('${b.id}')" title="L√∂schen" style="color:#ef4444">üóëÔ∏è</button>
                  </div>
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    ` : ''}
  `;
}

function toggleCancelledBookings() {
  window.showCancelledBookings = !window.showCancelledBookings;
  renderPage();
}

function renderProperties() {
  if (!properties.length) return '<div class="empty-state"><div class="empty-icon">üè†</div><div class="empty-title">Keine Objekte</div><button class="btn btn-primary" onclick="showAddProp()">+ Objekt</button></div>';
  
  return `
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
      <div style="font-size:14px;color:#a1a1aa">${properties.length} Objekt${properties.length > 1 ? 'e' : ''}</div>
      <button class="btn btn-sm btn-primary" onclick="showAddProp()">+ Neues Objekt</button>
    </div>
    <div class="grid-3">
      ${properties.map(p => `
        <div class="card property-card">
          <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
            <div style="font-size:32px">${p.property_type === 'house' ? 'üè°' : 'üè¢'}</div>
            <span class="tag ${p.active !== false ? 'tag-green' : 'tag-orange'}">${p.active !== false ? 'Aktiv' : 'Inaktiv'}</span>
          </div>
          <div style="font-weight:700;font-size:16px;margin-bottom:4px">${p.name}</div>
          <div style="color:#71717a;font-size:13px;margin-bottom:8px">${p.city || '-'}</div>
          <div style="font-size:12px;color:#a1a1aa;margin-bottom:12px">üõèÔ∏è ${p.bedrooms || 1} Zimmer ¬∑ üë• ${p.max_guests || 2} G√§ste</div>
          ${p.base_price ? `<div style="font-size:18px;font-weight:700;color:#22c55e;margin-bottom:12px">‚Ç¨${p.base_price}/Nacht</div>` : '<div style="margin-bottom:12px"></div>'}
          ${p.smoobu_id ? '<div style="font-size:10px;color:#71717a;margin-bottom:12px">üîó Smoobu verbunden</div>' : '<div style="margin-bottom:12px"></div>'}
          <div style="display:flex;gap:8px;border-top:1px solid #27272a;padding-top:12px;margin-top:auto">
            <button class="btn btn-sm btn-secondary" onclick="editProperty('${p.id}')" style="flex:1">‚úèÔ∏è Bearbeiten</button>
            <button class="btn btn-sm btn-secondary" onclick="deleteProperty('${p.id}')" style="color:#ef4444">üóëÔ∏è</button>
          </div>
        </div>
      `).join('')}
      <div class="card" style="border-style:dashed;display:flex;align-items:center;justify-content:center;min-height:220px;cursor:pointer" onclick="showAddProp()">
        <div style="text-align:center;color:#71717a">
          <div style="font-size:32px;margin-bottom:8px">+</div>
          <div>Hinzuf√ºgen</div>
        </div>
      </div>
    </div>
  `;
}

function renderPartners() {
  return '<div style="max-width:650px;margin:80px auto;text-align:center">' +
    '<div class="card" style="background:linear-gradient(135deg,#131316 0%,#1a1a2e 50%,#1e1e3f 100%);border:2px solid #f9731640;padding:56px 40px;border-radius:20px;box-shadow:0 20px 60px rgba(249,115,22,0.1)">' +
      '<div style="font-size:72px;margin-bottom:28px">ü§ù</div>' +
      '<div style="font-size:28px;font-weight:700;margin-bottom:16px;background:linear-gradient(135deg,#f97316,#fb923c);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">Bald neu f√ºr dich!</div>' +
      '<div style="font-size:18px;color:#fafafa;line-height:1.7;margin-bottom:8px">Das <strong style="color:#f97316">PilotStay Partnernetzwerk</strong></div>' +
      '<div style="font-size:16px;color:#a1a1aa;line-height:1.7;margin-bottom:32px">F√ºr noch mehr Entlastung und Zeitgewinn bei der Verwaltung deiner Unterk√ºnfte.</div>' +
      '<div style="display:flex;flex-wrap:wrap;gap:16px;justify-content:center;margin-top:40px">' +
        '<div style="background:#27272a;border-radius:16px;padding:20px 24px;text-align:center;min-width:150px;border:1px solid #3f3f46">' +
          '<div style="font-size:32px;margin-bottom:10px">üßπ</div>' +
          '<div style="font-size:14px;font-weight:600;color:#fafafa">Reinigung</div>' +
          '<div style="font-size:11px;color:#71717a;margin-top:4px">Professionelle Partner</div>' +
        '</div>' +
        '<div style="background:#27272a;border-radius:16px;padding:20px 24px;text-align:center;min-width:150px;border:1px solid #3f3f46">' +
          '<div style="font-size:32px;margin-bottom:10px">üîê</div>' +
          '<div style="font-size:14px;font-weight:600;color:#fafafa">Smart Locks</div>' +
          '<div style="font-size:11px;color:#71717a;margin-top:4px">Schl√ºssellose √úbergabe</div>' +
        '</div>' +
        '<div style="background:#27272a;border-radius:16px;padding:20px 24px;text-align:center;min-width:150px;border:1px solid #3f3f46">' +
          '<div style="font-size:32px;margin-bottom:10px">üì∏</div>' +
          '<div style="font-size:14px;font-weight:600;color:#fafafa">Fotografie</div>' +
          '<div style="font-size:11px;color:#71717a;margin-top:4px">Professionelle Bilder</div>' +
        '</div>' +
        '<div style="background:#27272a;border-radius:16px;padding:20px 24px;text-align:center;min-width:150px;border:1px solid #3f3f46">' +
          '<div style="font-size:32px;margin-bottom:10px">üõ†Ô∏è</div>' +
          '<div style="font-size:14px;font-weight:600;color:#fafafa">Handwerker</div>' +
          '<div style="font-size:11px;color:#71717a;margin-top:4px">Reparaturen & Wartung</div>' +
        '</div>' +
      '</div>' +
      '<div style="margin-top:40px;padding-top:28px;border-top:1px solid #27272a">' +
        '<div style="font-size:13px;color:#71717a">üîî Du wirst benachrichtigt, sobald das Partnernetzwerk verf√ºgbar ist.</div>' +
      '</div>' +
    '</div>' +
  '</div>';
}

function renderAutomation() {
  const smoobuConnected = smoobuConfig.connected;
  const lastSync = smoobuConfig.lastSync ? new Date(smoobuConfig.lastSync).toLocaleString('de-DE') : 'Nie';
  
  // Helper to display next sync time
  function getNextSyncDisplay() {
    const nextSync = parseInt(localStorage.getItem('smoobu_next_sync')) || 0;
    if (!nextSync) return '';
    
    const now = Date.now();
    const diff = nextSync - now;
    
    if (diff <= 0) return 'N√§chster Sync: F√§llig';
    
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `N√§chster Sync: in ${hours}h ${minutes % 60}min`;
    }
    return `N√§chster Sync: in ${minutes} min`;
  }
  
  // Calculate active features count (only count if enabled AND not 'off')
  const activeFeatures = [
    automationSettings.smartReplies && automationSettings.smartRepliesMode !== 'off',
    automationSettings.reviewReplies && automationSettings.reviewRepliesMode !== 'off',
    automationSettings.autoPricing && automationSettings.autoPricingMode !== 'off',
    automationSettings.autoJobs && automationSettings.autoJobsMode !== 'off',
    smoobuConnected
  ].filter(Boolean).length;
  
  // Count auto features
  const autoFeatures = [
    automationSettings.smartRepliesMode === 'auto' || automationSettings.smartRepliesMode === 'hybrid',
    automationSettings.reviewRepliesMode === 'auto',
    automationSettings.autoPricingMode === 'auto'
  ].filter(Boolean).length;
  
  const totalFeatures = 5;
  const score = Math.round((activeFeatures / totalFeatures) * 100);
  
  // Mode labels and colors
  const modeLabels = {
    'off': { label: 'Aus', color: '#71717a', icon: '‚≠ï' },
    'manual': { label: 'Manuell', color: '#3b82f6', icon: 'üõ°Ô∏è' },
    'auto': { label: 'Automatisch', color: '#22c55e', icon: 'ü§ñ' },
    'hybrid': { label: 'Hybrid', color: '#8b5cf6', icon: '‚ö°' }
  };
  
  return `
    <div class="card card-ai" style="margin-bottom:24px">
      <div style="display:flex;align-items:center;gap:24px;flex-wrap:wrap">
        <div style="text-align:center;min-width:100px">
          <div style="font-size:48px;font-weight:700;color:${score >= 80 ? '#22c55e' : score >= 50 ? '#8b5cf6' : '#f97316'}">${score}%</div>
          <div style="font-size:11px;color:#a1a1aa">KI-Score</div>
        </div>
        <div style="flex:1;padding-left:20px;border-left:1px solid #27272a;min-width:200px">
          <div style="font-size:18px;font-weight:700;margin-bottom:4px">${activeFeatures} von ${totalFeatures} Features aktiv</div>
          <div style="color:#a1a1aa;font-size:13px">
            ${autoFeatures > 0 ? `ü§ñ ${autoFeatures} laufen vollautomatisch` : 'Aktiviere Auto-Modus f√ºr maximale Zeitersparnis'}
          </div>
          <div style="margin-top:12px;background:#27272a;border-radius:10px;height:8px;overflow:hidden">
            <div style="background:linear-gradient(90deg,#8b5cf6,#a78bfa);height:100%;width:${score}%;transition:width .5s"></div>
          </div>
        </div>
        <button class="btn btn-ai" onclick="showAiSettings()">‚öôÔ∏è KI-Einstellungen</button>
      </div>
    </div>
    
    <!-- SMOOBU INTEGRATION -->
    <div class="card" style="border-color:${smoobuConnected ? '#22c55e' : '#f97316'}50;background:linear-gradient(135deg,#131316,${smoobuConnected ? '#22c55e' : '#f97316'}08)">
      <div class="card-title" style="font-size:16px">
        <img src="https://www.smoobu.com/wp-content/uploads/2021/06/smoobu-logo.svg" style="height:24px;filter:brightness(0) invert(1)" onerror="this.style.display='none'">
        üîó Smoobu Integration
        ${smoobuConnected ? '<span class="tag tag-green" style="margin-left:auto">‚úì Verbunden</span>' : '<span class="tag tag-orange" style="margin-left:auto">Nicht verbunden</span>'}
      </div>
      
      ${smoobuConnected ? `
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:16px;margin-bottom:20px">
          <div style="background:#18181b;padding:16px;border-radius:10px;text-align:center">
            <div style="font-size:24px;font-weight:700;color:#22c55e">${properties.length}</div>
            <div style="font-size:11px;color:#71717a">Objekte synchronisiert</div>
          </div>
          <div style="background:#18181b;padding:16px;border-radius:10px;text-align:center">
            <div style="font-size:24px;font-weight:700;color:#3b82f6">${bookings.length}</div>
            <div style="font-size:11px;color:#71717a">Buchungen importiert</div>
          </div>
          <div style="background:#18181b;padding:16px;border-radius:10px;text-align:center">
            <div style="font-size:24px;font-weight:700;color:#8b5cf6">${getSyncIntervalDisplay()}</div>
            <div style="font-size:11px;color:#71717a">Sync-Intervall</div>
          </div>
        </div>
        
        <div style="display:flex;align-items:center;gap:12px;padding:12px;background:#18181b;border-radius:10px;margin-bottom:16px">
          <div style="width:10px;height:10px;border-radius:50%;background:#22c55e;animation:pulse 2s infinite"></div>
          <div style="flex:1">
            <div style="font-size:13px">Auto-Sync aktiv</div>
            <div style="font-size:11px;color:#71717a">Letzter Sync: ${lastSync}</div>
            <div style="font-size:10px;color:#71717a">${getNextSyncDisplay()}</div>
          </div>
          <button class="btn btn-sm btn-secondary" onclick="syncSmoobuNow()">üîÑ Jetzt synchronisieren</button>
        </div>
        
        <div style="display:flex;gap:12px">
          <button class="btn btn-secondary" onclick="showSmoobuSettings()" style="flex:1">‚öôÔ∏è Einstellungen</button>
          <button class="btn btn-secondary" onclick="disconnectSmoobu()" style="color:#ef4444">Trennen</button>
        </div>
      ` : `
        <p style="color:#a1a1aa;font-size:13px;margin-bottom:16px">
          Verbinde dein Smoobu-Konto um Buchungen, Objekte und Preise automatisch zu synchronisieren.
        </p>
        
        <div style="background:#18181b;border-radius:10px;padding:16px;margin-bottom:16px">
          <div style="font-size:12px;color:#a1a1aa;margin-bottom:12px">So findest du deinen API-Key:</div>
          <ol style="font-size:12px;color:#71717a;padding-left:20px;line-height:1.8">
            <li>√ñffne <a href="https://login.smoobu.com" target="_blank" style="color:#f97316">login.smoobu.com</a></li>
            <li>Gehe zu <strong>Einstellungen ‚Üí F√ºr Entwickler</strong></li>
            <li>Klicke auf "API Key generieren"</li>
            <li>Kopiere den Key und f√ºge ihn unten ein</li>
          </ol>
        </div>
        
        <div style="margin-bottom:16px">
          <label class="label">Smoobu API-Key</label>
          <input class="input" type="password" id="smoobu-api-key" placeholder="Dein Smoobu API-Key..." value="${smoobuConfig.apiKey}">
        </div>
        
        <button class="btn btn-primary" onclick="connectSmoobu()" style="width:100%">
          üîó Mit Smoobu verbinden
        </button>
      `}
    </div>
    
    <!-- KI FEATURES with Mode Selection -->
    <div style="margin-top:24px;margin-bottom:16px;display:flex;justify-content:space-between;align-items:center">
      <div style="font-size:14px;font-weight:600;color:#a1a1aa">ü§ñ KI-Features</div>
      <div style="font-size:11px;color:#71717a">
        üõ°Ô∏è Manuell = Du best√§tigst ¬∑ ü§ñ Auto = KI handelt selbst ¬∑ ‚ö° Hybrid = Smart-Mix
      </div>
    </div>
    
    <!-- Pending Messages Alert -->
    ${pendingAutoReplies.length > 0 ? `
      <div class="card" style="background:#f9731610;border-color:#f9731650;margin-bottom:16px;cursor:pointer" onclick="showPendingReplies()">
        <div style="display:flex;align-items:center;gap:12px">
          <div style="font-size:24px">‚ö†Ô∏è</div>
          <div style="flex:1">
            <div style="font-weight:600">${pendingAutoReplies.length} Nachricht${pendingAutoReplies.length > 1 ? 'en' : ''} wartet auf Pr√ºfung</div>
            <div style="font-size:12px;color:#a1a1aa">Hybrid-Modus: Komplexe Anfragen brauchen deine Best√§tigung</div>
          </div>
          <button class="btn btn-sm btn-primary">Pr√ºfen ‚Üí</button>
        </div>
      </div>
    ` : ''}
    
    <div class="grid-2">
      <!-- Smart Replies -->
      <div class="card" style="${automationSettings.smartReplies ? 'border-color:#22c55e50' : ''}">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
          <div class="card-title" style="margin-bottom:0">üí¨ Smart Replies</div>
          <button class="toggle ${automationSettings.smartReplies ? 'active' : ''}" onclick="toggleAutomation('smartReplies')">
            <span class="toggle-knob"></span>
          </button>
        </div>
        <p style="color:#a1a1aa;font-size:13px;margin-bottom:12px">KI schl√§gt automatisch passende Antworten auf G√§steanfragen vor</p>
        
        ${automationSettings.smartReplies ? `
          <!-- Auto-Reply Status -->
          ${smoobuConfig.connected && (automationSettings.smartRepliesMode === 'auto' || automationSettings.smartRepliesMode === 'hybrid') ? `
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;padding:8px;background:#22c55e15;border-radius:6px">
              <div style="width:8px;height:8px;border-radius:50%;background:#22c55e;animation:pulse 2s infinite"></div>
              <span style="font-size:11px;color:#22c55e">Auto-Reply aktiv (pr√ºft alle 30s)</span>
            </div>
          ` : ''}
          
          <div style="margin-bottom:12px">
            <div style="font-size:11px;color:#71717a;margin-bottom:6px">Automatisierung:</div>
            <div style="display:flex;gap:6px">
              ${['manual', 'hybrid', 'auto'].map(mode => `
                <button class="btn btn-sm ${automationSettings.smartRepliesMode === mode ? 'btn-primary' : 'btn-secondary'}" 
                        onclick="setAutomationMode('smartReplies', '${mode}')"
                        style="flex:1;font-size:11px;padding:6px">
                  ${modeLabels[mode].icon} ${modeLabels[mode].label}
                </button>
              `).join('')}
            </div>
          </div>
          <div style="background:#18181b;padding:10px;border-radius:8px;font-size:11px;color:#a1a1aa">
            ${automationSettings.smartRepliesMode === 'manual' ? 'üõ°Ô∏è Du siehst Vorschl√§ge und entscheidest selbst' :
              automationSettings.smartRepliesMode === 'hybrid' ? '‚ö° Einfache Fragen (WLAN, Parkplatz) ‚Üí Auto ¬∑ Komplexe ‚Üí Manuell' :
              'ü§ñ KI antwortet automatisch auf alle G√§steanfragen'}
          </div>
        ` : `
          <div style="display:flex;align-items:center;gap:8px">
            <span class="tag tag-orange">Deaktiviert</span>
          </div>
        `}
      </div>
      
      <!-- Review Replies -->
      <div class="card" style="${automationSettings.reviewReplies ? 'border-color:#22c55e50' : ''}">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
          <div class="card-title" style="margin-bottom:0">‚≠ê Review-Antworten</div>
          <button class="toggle ${automationSettings.reviewReplies ? 'active' : ''}" onclick="toggleAutomation('reviewReplies')">
            <span class="toggle-knob"></span>
          </button>
        </div>
        <p style="color:#a1a1aa;font-size:13px;margin-bottom:12px">KI generiert personalisierte Antworten auf G√§stebewertungen</p>
        
        ${automationSettings.reviewReplies ? `
          <div style="margin-bottom:12px">
            <div style="font-size:11px;color:#71717a;margin-bottom:6px">Automatisierung:</div>
            <div style="display:flex;gap:6px">
              ${['manual', 'auto'].map(mode => `
                <button class="btn btn-sm ${automationSettings.reviewRepliesMode === mode ? 'btn-primary' : 'btn-secondary'}" 
                        onclick="setAutomationMode('reviewReplies', '${mode}')"
                        style="flex:1;font-size:11px;padding:6px">
                  ${modeLabels[mode].icon} ${modeLabels[mode].label}
                </button>
              `).join('')}
            </div>
          </div>
          <div style="background:#18181b;padding:10px;border-radius:8px;font-size:11px;color:#a1a1aa">
            ${automationSettings.reviewRepliesMode === 'manual' ? 'üõ°Ô∏è KI generiert Vorschl√§ge, du ver√∂ffentlichst manuell' :
              'ü§ñ KI antwortet automatisch auf neue Bewertungen'}
          </div>
        ` : `
          <div style="display:flex;align-items:center;gap:8px">
            <span class="tag tag-orange">Deaktiviert</span>
          </div>
        `}
      </div>
      
      <!-- Auto Pricing -->
      <div class="card" style="${automationSettings.autoPricing ? 'border-color:#22c55e50' : ''}">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
          <div class="card-title" style="margin-bottom:0">üí∞ Auto-Pricing</div>
          <button class="toggle ${automationSettings.autoPricing ? 'active' : ''}" onclick="toggleAutomation('autoPricing')">
            <span class="toggle-knob"></span>
          </button>
        </div>
        <p style="color:#a1a1aa;font-size:13px;margin-bottom:12px">KI optimiert Preise basierend auf Nachfrage, Events & Saison</p>
        
        ${automationSettings.autoPricing ? `
          <div style="margin-bottom:12px">
            <div style="font-size:11px;color:#71717a;margin-bottom:6px">Automatisierung:</div>
            <div style="display:flex;gap:6px">
              ${['manual', 'auto'].map(mode => `
                <button class="btn btn-sm ${automationSettings.autoPricingMode === mode ? 'btn-primary' : 'btn-secondary'}" 
                        onclick="setAutomationMode('autoPricing', '${mode}')"
                        style="flex:1;font-size:11px;padding:6px">
                  ${modeLabels[mode].icon} ${modeLabels[mode].label}
                </button>
              `).join('')}
            </div>
          </div>
          <div style="background:#18181b;padding:10px;border-radius:8px;font-size:11px;color:#a1a1aa">
            ${automationSettings.autoPricingMode === 'manual' ? 'üõ°Ô∏è Du siehst Preisvorschl√§ge und √ºbertr√§gst manuell' :
              'ü§ñ KI passt Preise automatisch an und synct zu Smoobu'}
          </div>
        ` : `
          <div style="display:flex;align-items:center;gap:8px">
            <span class="tag tag-orange">Deaktiviert</span>
          </div>
        `}
      </div>
      
      <!-- Auto Jobs -->
      <div class="card" style="${automationSettings.autoJobs ? 'border-color:#22c55e50' : ''}">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
          <div class="card-title" style="margin-bottom:0">üìã Auto-Jobs</div>
          <button class="toggle ${automationSettings.autoJobs ? 'active' : ''}" onclick="toggleAutomation('autoJobs')">
            <span class="toggle-knob"></span>
          </button>
        </div>
        <p style="color:#a1a1aa;font-size:13px;margin-bottom:12px">Erstellt automatisch Reinigungsauftr√§ge bei Check-out</p>
        
        ${automationSettings.autoJobs ? `
          <div style="margin-bottom:12px">
            <div style="font-size:11px;color:#71717a;margin-bottom:6px">Automatisierung:</div>
            <div style="display:flex;gap:6px">
              ${['manual', 'auto'].map(mode => `
                <button class="btn btn-sm ${automationSettings.autoJobsMode === mode ? 'btn-primary' : 'btn-secondary'}" 
                        onclick="setAutomationMode('autoJobs', '${mode}')"
                        style="flex:1;font-size:11px;padding:6px">
                  ${modeLabels[mode].icon} ${modeLabels[mode].label}
                </button>
              `).join('')}
            </div>
          </div>
          <div style="background:#18181b;padding:10px;border-radius:8px;font-size:11px;color:#a1a1aa">
            ${automationSettings.autoJobsMode === 'manual' ? 'üõ°Ô∏è Du erh√§ltst Benachrichtigungen und erstellst Jobs manuell' :
              'ü§ñ Jobs werden automatisch erstellt und Reinigungskr√§fte benachrichtigt'}
          </div>
        ` : `
          <div style="display:flex;align-items:center;gap:8px">
            <span class="tag tag-orange">Deaktiviert</span>
          </div>
        `}
      </div>
    </div>
    
    <!-- AI Learning Card -->
    <div class="card" style="margin-top:20px;background:linear-gradient(135deg,#131316,#8b5cf608);border-color:#8b5cf630">
      <div style="display:flex;align-items:start;gap:16px">
        <div style="font-size:32px">üß†</div>
        <div style="flex:1">
          <div style="font-size:16px;font-weight:700;margin-bottom:4px">KI-Lernen & Personalisierung</div>
          <div style="font-size:13px;color:#a1a1aa;margin-bottom:12px">
            Die KI lernt aus deinem Feedback und wird mit der Zeit besser
          </div>
          <div style="display:flex;gap:12px;flex-wrap:wrap">
            <div style="background:#18181b;padding:10px 14px;border-radius:8px;font-size:12px">
              <span style="color:#22c55e;font-weight:600">${aiContext.feedbackHistory.length}</span>
              <span style="color:#71717a"> Bewertungen</span>
            </div>
            <div style="background:#18181b;padding:10px 14px;border-radius:8px;font-size:12px">
              <span style="color:#3b82f6;font-weight:600">${aiContext.savedReplies.length}</span>
              <span style="color:#71717a"> Gespeicherte Antworten</span>
            </div>
            <div style="background:#18181b;padding:10px 14px;border-radius:8px;font-size:12px">
              <span style="color:#8b5cf6;font-weight:600">${Object.keys(aiContext.properties).length}</span>
              <span style="color:#71717a"> Objekt-Profile</span>
            </div>
          </div>
        </div>
        <button class="btn btn-sm btn-secondary" onclick="showPropertyContextManager()">Objekt-Infos ‚Üí</button>
      </div>
    </div>
    
    <!-- Zeit-Ersparnis Summary -->
    <div class="card" style="margin-top:20px;background:linear-gradient(135deg,#131316,#22c55e08);border-color:#22c55e30">
      <div style="display:flex;align-items:center;gap:20px">
        <div style="font-size:40px">‚è±Ô∏è</div>
        <div style="flex:1">
          <div style="font-size:16px;font-weight:700;color:#22c55e">
            ~${calculateTimeSaved()}h pro Woche gespart
          </div>
          <div style="font-size:12px;color:#a1a1aa;margin-top:4px">
            Durch ${activeFeatures} aktive Automatisierungen
            ${autoFeatures > 0 ? ` (${autoFeatures} vollautomatisch)` : ''}
          </div>
        </div>
        ${activeFeatures < totalFeatures ? `
          <button class="btn btn-sm btn-success" onclick="activateAllAutomation()">
            Alle aktivieren
          </button>
        ` : ''}
      </div>
    </div>
  `;
}

// Set automation mode for a feature
function setAutomationMode(feature, mode) {
  automationSettings[feature + 'Mode'] = mode;
  localStorage.setItem(feature.replace(/([A-Z])/g, '_$1').toLowerCase() + '_mode', mode);
  saveAutomationSettings();
  
  const modeNames = { manual: 'Manuell', auto: 'Automatisch', hybrid: 'Hybrid' };
  const featureNames = {
    smartReplies: 'Smart Replies',
    reviewReplies: 'Review-Antworten', 
    autoPricing: 'Auto-Pricing',
    autoJobs: 'Auto-Jobs'
  };
  
  showToast(`${featureNames[feature]}: ${modeNames[mode]} Modus aktiviert`);
  
  // If switching smartReplies to auto/hybrid, ensure polling is running
  if (feature === 'smartReplies' && (mode === 'auto' || mode === 'hybrid')) {
    if (smoobuConfig.connected && automationSettings.smartReplies) {
      startMessagePolling();
      showToast('ü§ñ KI antwortet jetzt automatisch auf Nachrichten!');
    }
  }
  
  renderPage();
}

// Show AI Settings Modal
function showAiSettings() {
  showModal(`
    <div class="modal-title">‚öôÔ∏è KI-Einstellungen</div>
    
    <div style="margin-bottom:20px">
      <label class="label">üó£Ô∏è Kommunikationsstil</label>
      <select class="input" id="ai-tone" onchange="updateAiTone(this.value)">
        <option value="formal" ${automationSettings.aiTone === 'formal' ? 'selected' : ''}>Formell (Sie-Form)</option>
        <option value="friendly" ${automationSettings.aiTone === 'friendly' ? 'selected' : ''}>Freundlich (Du-Form)</option>
        <option value="casual" ${automationSettings.aiTone === 'casual' ? 'selected' : ''}>Locker (Du + Emojis)</option>
      </select>
      <div style="font-size:11px;color:#71717a;margin-top:4px">Bestimmt wie die KI mit G√§sten kommuniziert</div>
    </div>
    
    <div style="margin-bottom:20px">
      <label class="label">üåç Sprache</label>
      <select class="input" id="ai-language" onchange="updateAiLanguage(this.value)">
        <option value="de" ${automationSettings.aiLanguage === 'de' ? 'selected' : ''}>Deutsch</option>
        <option value="en" ${automationSettings.aiLanguage === 'en' ? 'selected' : ''}>English</option>
        <option value="auto" ${automationSettings.aiLanguage === 'auto' ? 'selected' : ''}>Auto (erkennt Sprache des Gastes)</option>
      </select>
    </div>
    
    <div style="margin-bottom:20px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <label class="label" style="margin:0">üß† KI-Lernen aktivieren</label>
        <button class="toggle ${automationSettings.aiLearning ? 'active' : ''}" onclick="toggleAiLearning()">
          <span class="toggle-knob"></span>
        </button>
      </div>
      <div style="font-size:11px;color:#71717a">
        Die KI speichert erfolgreiche Antworten und lernt aus deinem Feedback (üëç/üëé)
      </div>
    </div>
    
    <div style="border-top:1px solid #27272a;padding-top:16px;margin-top:16px">
      <div style="font-size:12px;font-weight:600;margin-bottom:8px">‚ö†Ô∏è Gefahrenzone</div>
      <button class="btn btn-secondary" onclick="resetAiLearning()" style="color:#ef4444;font-size:12px">
        üóëÔ∏è Alle gelernten Daten l√∂schen
      </button>
    </div>
    
    <div style="display:flex;gap:12px;margin-top:20px">
      <button class="btn btn-primary" onclick="hideModal()" style="flex:1">Fertig</button>
    </div>
  `);
}

function updateAiTone(tone) {
  automationSettings.aiTone = tone;
  localStorage.setItem('ai_tone', tone);
  saveAutomationSettings();
  showToast('‚úÖ Kommunikationsstil aktualisiert');
}

function updateAiLanguage(lang) {
  automationSettings.aiLanguage = lang;
  localStorage.setItem('ai_language', lang);
  saveAutomationSettings();
  showToast('‚úÖ Sprache aktualisiert');
}

function toggleAiLearning() {
  automationSettings.aiLearning = !automationSettings.aiLearning;
  localStorage.setItem('ai_learning', automationSettings.aiLearning);
  saveAutomationSettings();
  showToast(automationSettings.aiLearning ? '‚úÖ KI-Lernen aktiviert' : '‚ùå KI-Lernen deaktiviert');
  showAiSettings(); // Refresh modal
}

function resetAiLearning() {
  if (confirm('Bist du sicher? Alle gelernten Daten werden gel√∂scht.')) {
    aiContext = {
      properties: {},
      savedReplies: [],
      feedbackHistory: [],
      commonQuestions: {}
    };
    localStorage.removeItem('ai_context');
    showToast('üóëÔ∏è KI-Daten gel√∂scht');
    hideModal();
    renderPage();
  }
}

// Property Context Manager
function showPropertyContextManager() {
  const propList = properties.map(p => {
    const ctx = aiContext.properties[p.id] || {};
    return `
      <div class="card" style="margin-bottom:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:600">${p.name}</div>
            <div style="font-size:11px;color:#71717a">${p.city || 'Keine Stadt'}</div>
          </div>
          <button class="btn btn-sm btn-secondary" onclick="editPropertyContext('${p.id}')">
            ${Object.keys(ctx).length > 0 ? '‚úèÔ∏è Bearbeiten' : '+ Infos hinzuf√ºgen'}
          </button>
        </div>
        ${Object.keys(ctx).length > 0 ? `
          <div style="margin-top:12px;display:flex;flex-wrap:wrap;gap:6px">
            ${ctx.wifi ? '<span class="tag tag-green">üì∂ WLAN</span>' : ''}
            ${ctx.parking ? '<span class="tag tag-green">üöó Parkplatz</span>' : ''}
            ${ctx.checkin ? '<span class="tag tag-green">üîë Check-in</span>' : ''}
            ${ctx.checkout ? '<span class="tag tag-green">üèÅ Checkout</span>' : ''}
            ${ctx.houseRules ? '<span class="tag tag-green">üìã Hausregeln</span>' : ''}
          </div>
        ` : ''}
      </div>
    `;
  }).join('');
  
  showModal(`
    <div class="modal-title">üè† Objekt-Informationen f√ºr KI</div>
    <div style="font-size:13px;color:#a1a1aa;margin-bottom:16px">
      F√ºge wichtige Infos hinzu, damit die KI bessere Antworten geben kann
    </div>
    
    ${properties.length > 0 ? propList : `
      <div style="text-align:center;padding:30px;color:#71717a">
        <div style="font-size:32px;margin-bottom:8px">üè†</div>
        Verbinde erst Smoobu um Objekte zu sehen
      </div>
    `}
    
    <button class="btn btn-secondary" onclick="hideModal()" style="width:100%;margin-top:12px">Schlie√üen</button>
  `);
}

function editPropertyContext(propertyId) {
  const property = properties.find(p => p.id === propertyId);
  const ctx = aiContext.properties[propertyId] || {};
  
  showModal(`
    <div class="modal-title">üè† ${property?.name || 'Objekt'} - KI Infos</div>
    
    <div style="margin-bottom:16px">
      <label class="label">üì∂ WLAN-Passwort</label>
      <input class="input" id="ctx-wifi" placeholder="z.B. Guest2024" value="${ctx.wifi || ''}">
    </div>
    
    <div style="margin-bottom:16px">
      <label class="label">üöó Parkplatz-Info</label>
      <input class="input" id="ctx-parking" placeholder="z.B. Kostenlos vor dem Haus" value="${ctx.parking || ''}">
    </div>
    
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
      <div>
        <label class="label">üîë Check-in Zeit</label>
        <input class="input" type="time" id="ctx-checkin" value="${ctx.checkin || '15:00'}">
      </div>
      <div>
        <label class="label">üèÅ Check-out Zeit</label>
        <input class="input" type="time" id="ctx-checkout" value="${ctx.checkout || '11:00'}">
      </div>
    </div>
    
    <div style="margin-bottom:16px">
      <label class="label">üìã Hausregeln</label>
      <textarea class="input" id="ctx-rules" placeholder="z.B. Nicht rauchen, keine Partys..." style="min-height:80px">${ctx.houseRules || ''}</textarea>
    </div>
    
    <div style="margin-bottom:16px">
      <label class="label">üìù Weitere wichtige Infos</label>
      <textarea class="input" id="ctx-custom" placeholder="Alles was die KI sonst noch wissen sollte..." style="min-height:80px">${ctx.customInfo || ''}</textarea>
    </div>
    
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="showPropertyContextManager()" style="flex:1">Zur√ºck</button>
      <button class="btn btn-primary" onclick="savePropertyContext('${propertyId}')" style="flex:1">üíæ Speichern</button>
    </div>
  `);
}

function savePropertyContext(propertyId) {
  aiContext.properties[propertyId] = {
    wifi: document.getElementById('ctx-wifi').value,
    parking: document.getElementById('ctx-parking').value,
    checkin: document.getElementById('ctx-checkin').value,
    checkout: document.getElementById('ctx-checkout').value,
    houseRules: document.getElementById('ctx-rules').value,
    customInfo: document.getElementById('ctx-custom').value
  };
  
  // Save to localStorage
  localStorage.setItem('ai_context', JSON.stringify(aiContext));
  
  // Save to Supabase for cross-device sync
  saveAiContextToSupabase();
  
  showToast('‚úÖ Objekt-Infos gespeichert');
  showPropertyContextManager();
}

// =====================
// AUTO-REPLY PROCESSOR
// =====================

// Process incoming message and potentially auto-reply
async function processIncomingMessage(chat, message) {
  // Check if smart replies is enabled
  if (!automationSettings.smartReplies) return null;
  
  const mode = automationSettings.smartRepliesMode;
  
  // If manual mode, just generate suggestions (handled elsewhere)
  if (mode === 'manual') return null;
  
  // Check if this is a simple or complex question
  const isSimple = isSimpleQuestion(message.text);
  
  // If hybrid mode and complex question, don't auto-reply
  if (mode === 'hybrid' && !isSimple) {
    console.log('Hybrid mode: Complex question detected, needs manual approval');
    return { needsApproval: true, reason: 'Komplexe Frage erkannt' };
  }
  
  // Generate AI response
  try {
    const response = await generateAutoReply(chat, message);
    
    if (mode === 'auto' || (mode === 'hybrid' && isSimple)) {
      // Auto-send the response
      return { autoSent: true, response };
    }
    
    return { suggestion: response };
  } catch (error) {
    console.error('Auto-reply error:', error);
    return { error: error.message };
  }
}

// Generate auto-reply using AI
async function generateAutoReply(chat, message) {
  // Get property context
  const booking = bookings.find(b => b.guest_name?.includes(chat.name.split(' ')[0]));
  const property = booking ? properties.find(p => p.id === booking.property_id) : properties[0];
  const propertyContext = property ? aiContext.properties[property.id] : null;
  
  // Get conversation history
  const history = chat.messages.slice(-6).map(m => m.text);
  
  // Build context for AI
  const contextInfo = propertyContext ? `
    Objekt: ${property.name}
    WLAN: ${propertyContext.wifi || 'Nicht angegeben'}
    Parkplatz: ${propertyContext.parking || 'Nicht angegeben'}
    Check-in: ${propertyContext.checkin || '15:00'}
    Check-out: ${propertyContext.checkout || '11:00'}
    Hausregeln: ${propertyContext.houseRules || 'Keine'}
    Weitere Infos: ${propertyContext.customInfo || 'Keine'}
  ` : '';
  
  const session = await db.auth.getSession();
  const token = session?.data?.session?.access_token || '';
  
  const response = await fetch(AI_PROXY_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer ' + token
    },
    body: JSON.stringify({
      action: 'auto-reply',
      data: {
        guestName: chat.name,
        guestMessage: message.text,
        conversationHistory: history,
        propertyContext: contextInfo,
        tone: automationSettings.aiTone,
        language: automationSettings.aiLanguage
      }
    })
  });
  
  if (!response.ok) throw new Error('AI request failed');
  
  const data = await response.json();
  return data.reply;
}

// Simulate incoming message (for demo/testing)
function simulateIncomingMessage(chatId, messageText) {
  const chat = chats.find(c => c.id == chatId);
  if (!chat) return;
  
  const newMessage = {
    id: 'm' + Date.now(),
    from: 'them',
    text: messageText,
    time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'})
  };
  
  chat.messages.push(newMessage);
  chat.unread++;
  chat.lastMsg = messageText;
  
  // Process with auto-reply
  processIncomingMessage(chat, newMessage).then(result => {
    if (result?.autoSent) {
      // Add AI response to chat
      chat.messages.push({
        id: 'm' + Date.now(),
        from: 'me',
        text: result.response,
        time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}),
        ai: true,
        autoSent: true
      });
      chat.lastMsg = result.response;
      chat.unread = 0;
      showToast('ü§ñ Auto-Reply gesendet: ' + chat.name);
    } else if (result?.needsApproval) {
      showToast('‚ö†Ô∏è Neue Nachricht von ' + chat.name + ' - Manuelle Pr√ºfung n√∂tig');
    }
    renderPage();
  });
  
  renderPage();
}

// =====================
// FEEDBACK SYSTEM
// =====================

// Rate an AI response
function rateAiResponse(messageId, rating) {
  // Find the message
  let foundChat = null;
  let foundMessage = null;
  
  for (const chat of chats) {
    const msg = chat.messages.find(m => m.id === messageId);
    if (msg) {
      foundChat = chat;
      foundMessage = msg;
      break;
    }
  }
  
  if (!foundMessage) return;
  
  // Save feedback
  const feedback = {
    messageId,
    chatId: foundChat.id,
    guestMessage: foundChat.messages[foundChat.messages.indexOf(foundMessage) - 1]?.text || '',
    response: foundMessage.text,
    rating, // 'good' or 'bad'
    timestamp: new Date().toISOString()
  };
  
  aiContext.feedbackHistory.push(feedback);
  
  // If good rating, save as successful reply
  if (rating === 'good' && automationSettings.aiLearning) {
    aiContext.savedReplies.push({
      question: feedback.guestMessage,
      answer: feedback.response,
      useCount: 1
    });
  }
  
  // Save to localStorage
  localStorage.setItem('ai_context', JSON.stringify(aiContext));
  saveAiContextToSupabase();
  
  // Mark message as rated
  foundMessage.rated = rating;
  
  showToast(rating === 'good' ? 'üëç Danke! KI lernt dazu.' : 'üëé Verstanden, wird verbessert.');
  renderPage();
}

// Save AI context to Supabase
async function saveAiContextToSupabase() {
  try {
    await db.from('profiles').update({
      ai_context: aiContext
    }).eq('id', user.id);
  } catch (e) {
    console.log('Could not save AI context to Supabase:', e);
  }
}

// Load AI context from Supabase
async function loadAiContextFromSupabase() {
  try {
    const { data } = await db.from('profiles').select('ai_context').eq('id', user.id).single();
    if (data?.ai_context) {
      aiContext = { ...aiContext, ...data.ai_context };
    }
  } catch (e) {
    console.log('Using local AI context:', e);
  }
  
  // Also try localStorage as fallback
  const localContext = localStorage.getItem('ai_context');
  if (localContext) {
    try {
      const parsed = JSON.parse(localContext);
      aiContext = { ...aiContext, ...parsed };
    } catch (e) {}
  }
}

// =====================
// AUTOMATION TOGGLE FUNCTIONS
// =====================

function toggleAutomation(feature) {
  // Toggle the setting
  automationSettings[feature] = !automationSettings[feature];
  
  // Save to localStorage
  localStorage.setItem('auto_' + feature.replace(/([A-Z])/g, '_$1').toLowerCase(), automationSettings[feature]);
  
  // Save to Supabase (for cross-device sync)
  saveAutomationSettings();
  
  // Show feedback
  const featureNames = {
    smartReplies: 'Smart Replies',
    reviewReplies: 'Review-Antworten',
    autoPricing: 'Auto-Pricing',
    autoJobs: 'Auto-Jobs'
  };
  
  showToast(automationSettings[feature] 
    ? `‚úÖ ${featureNames[feature]} aktiviert` 
    : `‚ùå ${featureNames[feature]} deaktiviert`
  );
  
  // Start/stop message polling when smartReplies is toggled
  if (feature === 'smartReplies' && smoobuConfig.connected) {
    if (automationSettings.smartReplies) {
      startMessagePolling();
      requestNotificationPermission();
      showToast('ü§ñ Auto-Reply System gestartet');
    } else {
      stopMessagePolling();
    }
  }
  
  // Re-render the page
  renderPage();
}

function activateAllAutomation() {
  automationSettings.smartReplies = true;
  automationSettings.reviewReplies = true;
  automationSettings.autoPricing = true;
  automationSettings.autoJobs = true;
  
  // Save all
  localStorage.setItem('auto_smart_replies', 'true');
  localStorage.setItem('auto_review_replies', 'true');
  localStorage.setItem('auto_pricing', 'true');
  localStorage.setItem('auto_jobs', 'true');
  
  saveAutomationSettings();
  showToast('‚úÖ Alle Automatisierungen aktiviert!');
  renderPage();
}

async function saveAutomationSettings() {
  try {
    await db.from('profiles').update({
      // On/Off settings
      automation_smart_replies: automationSettings.smartReplies,
      automation_review_replies: automationSettings.reviewReplies,
      automation_pricing: automationSettings.autoPricing,
      automation_jobs: automationSettings.autoJobs,
      // Mode settings (manual/auto/hybrid)
      smart_replies_mode: automationSettings.smartRepliesMode,
      review_replies_mode: automationSettings.reviewRepliesMode,
      auto_pricing_mode: automationSettings.autoPricingMode,
      auto_jobs_mode: automationSettings.autoJobsMode,
      // AI settings
      ai_tone: automationSettings.aiTone,
      ai_language: automationSettings.aiLanguage,
      ai_learning: automationSettings.aiLearning,
      // AI Context (property infos, saved replies, feedback)
      ai_context: aiContext,
      // Smoobu settings
      smoobu_api_key: smoobuConfig.apiKey || null,
      smoobu_connected: smoobuConfig.connected,
      pricing_strategy: pricingData.strategy
    }).eq('id', user.id);
    
    // Also save to localStorage as backup
    localStorage.setItem('auto_smart_replies', automationSettings.smartReplies);
    localStorage.setItem('auto_review_replies', automationSettings.reviewReplies);
    localStorage.setItem('auto_pricing', automationSettings.autoPricing);
    localStorage.setItem('auto_jobs', automationSettings.autoJobs);
    localStorage.setItem('smart_replies_mode', automationSettings.smartRepliesMode);
    localStorage.setItem('review_replies_mode', automationSettings.reviewRepliesMode);
    localStorage.setItem('auto_pricing_mode', automationSettings.autoPricingMode);
    localStorage.setItem('auto_jobs_mode', automationSettings.autoJobsMode);
    localStorage.setItem('ai_tone', automationSettings.aiTone);
    localStorage.setItem('ai_language', automationSettings.aiLanguage);
    localStorage.setItem('ai_learning', automationSettings.aiLearning);
    localStorage.setItem('ai_context', JSON.stringify(aiContext));
    localStorage.setItem('pricing_strategy', pricingData.strategy);
    
  } catch (e) {
    console.log('Could not save to Supabase:', e);
  }
}

async function loadAutomationSettings() {
  try {
    const { data } = await db.from('profiles').select('*').eq('id', user.id).single();
    if (data) {
      // Load on/off settings
      if (data.automation_smart_replies !== undefined && data.automation_smart_replies !== null) {
        automationSettings.smartReplies = data.automation_smart_replies;
      }
      if (data.automation_review_replies !== undefined && data.automation_review_replies !== null) {
        automationSettings.reviewReplies = data.automation_review_replies;
      }
      if (data.automation_pricing !== undefined && data.automation_pricing !== null) {
        automationSettings.autoPricing = data.automation_pricing;
      }
      if (data.automation_jobs !== undefined && data.automation_jobs !== null) {
        automationSettings.autoJobs = data.automation_jobs;
      }
      
      // Load mode settings
      if (data.smart_replies_mode) {
        automationSettings.smartRepliesMode = data.smart_replies_mode;
      }
      if (data.review_replies_mode) {
        automationSettings.reviewRepliesMode = data.review_replies_mode;
      }
      if (data.auto_pricing_mode) {
        automationSettings.autoPricingMode = data.auto_pricing_mode;
      }
      if (data.auto_jobs_mode) {
        automationSettings.autoJobsMode = data.auto_jobs_mode;
      }
      
      // Load AI settings
      if (data.ai_tone) {
        automationSettings.aiTone = data.ai_tone;
      }
      if (data.ai_language) {
        automationSettings.aiLanguage = data.ai_language;
      }
      if (data.ai_learning !== undefined && data.ai_learning !== null) {
        automationSettings.aiLearning = data.ai_learning;
      }
      
      // Load AI Context
      if (data.ai_context) {
        aiContext = { ...aiContext, ...data.ai_context };
      }
      
      // Load Smoobu settings
      if (data.smoobu_api_key) {
        smoobuConfig.apiKey = data.smoobu_api_key;
        localStorage.setItem('smoobu_api_key', data.smoobu_api_key);
      }
      if (data.smoobu_connected !== undefined && data.smoobu_connected !== null) {
        smoobuConfig.connected = data.smoobu_connected;
        localStorage.setItem('smoobu_connected', data.smoobu_connected);
      }
      
      // Load Smoobu sync interval
      if (data.smoobu_sync_interval) {
        localStorage.setItem('smoobu_sync_interval', data.smoobu_sync_interval.toString());
      }
      
      // Load Smoobu last sync time
      if (data.smoobu_last_sync) {
        smoobuConfig.lastSync = data.smoobu_last_sync;
        localStorage.setItem('smoobu_last_sync', data.smoobu_last_sync);
      }
      
      // Load pricing strategy
      if (data.pricing_strategy) {
        pricingData.strategy = data.pricing_strategy;
        localStorage.setItem('pricing_strategy', data.pricing_strategy);
      }
    }
  } catch (e) {
    console.log('Using localStorage settings:', e);
    // Fallback to localStorage
    const localContext = localStorage.getItem('ai_context');
    if (localContext) {
      try {
        aiContext = { ...aiContext, ...JSON.parse(localContext) };
      } catch (parseError) {}
    }
  }
}

function calculateTimeSaved() {
  let hours = 0;
  if (automationSettings.smartReplies) hours += 2;
  if (automationSettings.reviewReplies) hours += 1;
  if (automationSettings.autoPricing) hours += 1.5;
  if (automationSettings.autoJobs) hours += 3;
  if (smoobuConfig.connected) hours += 2;
  return hours;
}

// Check if feature is enabled (used by other modules)
function isFeatureEnabled(feature) {
  return automationSettings[feature] === true;
}

// =====================
// SMOOBU FUNCTIONS
// =====================

async function connectSmoobu() {
  const apiKey = document.getElementById('smoobu-api-key').value.trim();
  if (!apiKey) {
    alert('Bitte API-Key eingeben');
    return;
  }
  
  // Show loading
  showModal(`
    <div style="text-align:center;padding:40px">
      <div class="spinner" style="margin:0 auto 20px"></div>
      <div style="font-size:16px;font-weight:600">Verbinde mit Smoobu...</div>
      <div style="color:#71717a;font-size:13px;margin-top:8px">API-Key wird √ºberpr√ºft</div>
    </div>
  `);
  
  try {
    // Test API connection via Edge Function
    const response = await fetch(`${SMOOBU_PROXY_URL}?action=me`, {
      method: 'GET',
      headers: { 
        'x-smoobu-key': apiKey,
        'Content-Type': 'application/json'
      }
    });
    
    const data = await response.json();
    
    if (!response.ok || data.error) {
      throw new Error(data.error || data.details?.detail || 'API-Key ung√ºltig');
    }
    
    // Success! Save config
    smoobuConfig.apiKey = apiKey;
    smoobuConfig.connected = true;
    smoobuConfig.lastSync = new Date().toISOString();
    smoobuConfig.smoobuUser = data;
    
    // Save to localStorage
    localStorage.setItem('smoobu_api_key', apiKey);
    localStorage.setItem('smoobu_connected', 'true');
    localStorage.setItem('smoobu_last_sync', smoobuConfig.lastSync);
    
    // Save to Supabase
    await db.from('profiles').update({
      smoobu_connected: true,
      smoobu_last_sync: smoobuConfig.lastSync
    }).eq('id', user.id);
    
    hideModal();
    
    // Show success with user info
    showModal(`
      <div style="text-align:center;padding:20px">
        <div style="font-size:64px;margin-bottom:16px">‚úÖ</div>
        <div style="font-size:18px;font-weight:700;margin-bottom:8px">Erfolgreich verbunden!</div>
        <div style="color:#a1a1aa;margin-bottom:8px">Smoobu-Konto: ${data.firstName} ${data.lastName}</div>
        <div style="color:#71717a;font-size:12px;margin-bottom:24px">${data.email}</div>
        <button class="btn btn-primary" onclick="hideModal();syncSmoobuNow()" style="width:100%">üîÑ Daten jetzt synchronisieren</button>
      </div>
    `);
    
    // Start auto-sync
    startSmoobuAutoSync();
    
  } catch (error) {
    hideModal();
    showModal(`
      <div style="text-align:center;padding:20px">
        <div style="font-size:64px;margin-bottom:16px">‚ùå</div>
        <div style="font-size:18px;font-weight:700;margin-bottom:8px">Verbindung fehlgeschlagen</div>
        <div style="color:#ef4444;margin-bottom:24px;font-size:13px">${error.message}</div>
        <button class="btn btn-secondary" onclick="hideModal()" style="width:100%">Schlie√üen</button>
      </div>
    `);
  }
}

function disconnectSmoobu() {
  if (!confirm('Smoobu-Verbindung wirklich trennen?')) return;
  
  smoobuConfig.connected = false;
  smoobuConfig.apiKey = '';
  
  localStorage.removeItem('smoobu_api_key');
  localStorage.removeItem('smoobu_connected');
  localStorage.removeItem('smoobu_last_sync');
  
  if (smoobuConfig.syncInterval) {
    clearInterval(smoobuConfig.syncInterval);
  }
  
  // Update Supabase
  db.from('hosts').update({ smoobu_connected: false }).eq('id', user.id);
  
  renderPage();
}

async function syncSmoobuNow() {
  if (!smoobuConfig.apiKey) {
    alert('Bitte zuerst Smoobu verbinden');
    return;
  }
  
  showModal(`
    <div style="text-align:center;padding:40px">
      <div class="spinner" style="margin:0 auto 20px"></div>
      <div style="font-size:16px;font-weight:600">Synchronisiere...</div>
      <div style="color:#71717a;font-size:13px;margin-top:8px" id="sync-status">Lade Objekte...</div>
    </div>
  `);
  
  try {
    // Step 1: Sync Apartments from Smoobu
    document.getElementById('sync-status').textContent = 'Lade Objekte aus Smoobu...';
    
    const apartmentsRes = await fetch(`${SMOOBU_PROXY_URL}?action=apartments`, {
      headers: { 'x-smoobu-key': smoobuConfig.apiKey }
    });
    const apartmentsData = await apartmentsRes.json();
    
    if (apartmentsData.apartments) {
      smoobuConfig.smoobuApartments = apartmentsData.apartments;
      
      // Sync to Supabase
      for (const apt of apartmentsData.apartments) {
        try {
          // Get details for each apartment
          const detailRes = await fetch(`${SMOOBU_PROXY_URL}?action=apartment&id=${apt.id}`, {
            headers: { 'x-smoobu-key': smoobuConfig.apiKey }
          });
          const detail = await detailRes.json();
          
          // Check if property already exists
          const { data: existingProps } = await db.from('properties')
            .select('id')
            .eq('smoobu_id', apt.id)
            .limit(1);
          
          const existing = existingProps && existingProps.length > 0 ? existingProps[0] : null;
          
          if (existing) {
            // Update existing - ONLY update Smoobu-specific fields, preserve user edits
            // First get current data to preserve user-edited fields
            const { data: currentData } = await db.from('properties')
              .select('city, zip, street, bedrooms, max_guests, base_price')
              .eq('id', existing.id)
              .single();
            
            const propertyData = {
              host_id: user.id,
              smoobu_id: apt.id,
              name: apt.name,
              // Only update location if user hasn't set their own value
              city: currentData?.city || detail.location?.city || '',
              zip: currentData?.zip || detail.location?.zip || '',
              street: currentData?.street || detail.location?.street || '',
              country: detail.location?.country || '',
              // Preserve user edits for these fields
              bedrooms: currentData?.bedrooms || detail.rooms?.bedrooms || 1,
              max_guests: currentData?.max_guests || detail.rooms?.maxOccupancy || 2,
              base_price: currentData?.base_price || (detail.price?.minimal ? parseFloat(detail.price.minimal) : null),
              property_type: 'apartment',
              active: true
            };
            
            await db.from('properties').update(propertyData).eq('id', existing.id);
          } else {
            // Insert new - use Smoobu data as initial values
            const propertyData = {
              host_id: user.id,
              smoobu_id: apt.id,
              name: apt.name,
              city: detail.location?.city || '',
              zip: detail.location?.zip || '',
              street: detail.location?.street || '',
              country: detail.location?.country || '',
              bedrooms: detail.rooms?.bedrooms || 1,
              max_guests: detail.rooms?.maxOccupancy || 2,
              base_price: detail.price?.minimal ? parseFloat(detail.price.minimal) : null,
              property_type: 'apartment',
              active: true
            };
            
            await db.from('properties').insert(propertyData);
          }
        } catch (propError) {
          console.error('Error syncing property:', apt.id, propError);
        }
      }
    }
    
    // Step 2: Sync Bookings from Smoobu
    document.getElementById('sync-status').textContent = 'Lade Buchungen aus Smoobu...';
    
    const bookingsRes = await fetch(`${SMOOBU_PROXY_URL}?action=bookings`, {
      headers: { 'x-smoobu-key': smoobuConfig.apiKey }
    });
    const bookingsData = await bookingsRes.json();
    
    if (bookingsData.bookings && bookingsData.bookings.length > 0) {
      for (const booking of bookingsData.bookings) {
        try {
          // Find local property by smoobu_id
          const { data: localProps } = await db.from('properties')
            .select('id')
            .eq('smoobu_id', booking.apartment?.id)
            .limit(1);
          
          const localProp = localProps && localProps.length > 0 ? localProps[0] : null;
          
          if (localProp) {
            // Check if booking already exists
            const { data: existingBookings } = await db.from('bookings')
              .select('id')
              .eq('smoobu_id', booking.id)
              .limit(1);
            
            const existingBooking = existingBookings && existingBookings.length > 0 ? existingBookings[0] : null;
            
            const bookingData = {
              host_id: user.id,
              property_id: localProp.id,
              smoobu_id: booking.id,
              guest_name: booking['guest-name'] || 'Unbekannt',
              guest_email: booking.email || '',
              guest_phone: booking.phone || '',
              check_in: booking.arrival,
              check_out: booking.departure,
              total_price: booking.price || 0,
              adults: booking.adults || 1,
              children: booking.children || 0,
              status: booking.type === 'cancellation' ? 'cancelled' : 'confirmed',
              source: booking.channel?.name || 'Smoobu'
            };
            
            if (existingBooking) {
              // Update existing
              await db.from('bookings').update(bookingData).eq('id', existingBooking.id);
            } else {
              // Insert new
              await db.from('bookings').insert(bookingData);
            }
          }
        } catch (bookingError) {
          console.error('Error syncing booking:', booking.id, bookingError);
        }
      }
    }
    
    // Step 3: Update pricing data from Smoobu
    document.getElementById('sync-status').textContent = 'Lade Preise...';
    
    if (smoobuConfig.smoobuApartments.length > 0) {
      const today = new Date().toISOString().split('T')[0];
      const endDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      const apartmentIds = smoobuConfig.smoobuApartments.map(a => a.id).join(',');
      
      const ratesRes = await fetch(
        `${SMOOBU_PROXY_URL}?action=rates&apartments=${apartmentIds}&start_date=${today}&end_date=${endDate}`,
        { headers: { 'x-smoobu-key': smoobuConfig.apiKey } }
      );
      const ratesData = await ratesRes.json();
      
      // Update local pricing data
      if (ratesData.data) {
        pricingData.properties = smoobuConfig.smoobuApartments.map(apt => {
          const rates = ratesData.data[apt.id] || {};
          const prices = Object.values(rates).map(r => r.price).filter(p => p);
          const avgPrice = prices.length ? Math.round(prices.reduce((a,b) => a+b, 0) / prices.length) : 80;
          
          return {
            id: apt.id,
            name: apt.name,
            basePrice: avgPrice,
            currentPrice: avgPrice,
            suggestedPrice: Math.round(avgPrice * 1.1), // Simple suggestion: +10%
            occupancy: Math.round(Math.random() * 40 + 50), // Placeholder
            factors: ['Saison-Anpassung', 'Wochenend-Aufschlag']
          };
        });
      }
    }
    
    // Update last sync time
    smoobuConfig.lastSync = new Date().toISOString();
    localStorage.setItem('smoobu_last_sync', smoobuConfig.lastSync);
    
    // Save lastSync to Supabase for cross-device sync
    try {
      await db.from('profiles').update({
        smoobu_last_sync: smoobuConfig.lastSync
      }).eq('id', user.id);
    } catch (e) {
      console.log('Could not save lastSync to Supabase:', e);
    }
    
    // Reload data from Supabase
    await loadData();
    
    hideModal();
    renderPage();
    
    // Show success toast
    const syncedProps = smoobuConfig.smoobuApartments.length;
    const syncedBookings = bookingsData.bookings?.length || 0;
    showToast(`‚úÖ Sync fertig: ${syncedProps} Objekte, ${syncedBookings} Buchungen`);
    
  } catch (error) {
    hideModal();
    console.error('Sync error:', error);
    showModal(`
      <div style="text-align:center;padding:20px">
        <div style="font-size:64px;margin-bottom:16px">‚ö†Ô∏è</div>
        <div style="font-size:18px;font-weight:700;margin-bottom:8px">Sync-Fehler</div>
        <div style="color:#ef4444;margin-bottom:24px;font-size:13px">${error.message}</div>
        <button class="btn btn-secondary" onclick="hideModal()" style="width:100%">Schlie√üen</button>
      </div>
    `);
  }
}

function startSmoobuAutoSync() {
  // Clear existing interval
  if (smoobuConfig.syncInterval) {
    clearInterval(smoobuConfig.syncInterval);
    smoobuConfig.syncInterval = null;
  }
  
  // Get saved interval (default: 60 minutes)
  const intervalMinutes = parseInt(localStorage.getItem('smoobu_sync_interval')) || 60;
  const intervalMs = intervalMinutes * 60 * 1000;
  
  console.log(`Auto-sync started: every ${intervalMinutes} minutes`);
  
  // Store next sync time
  const updateNextSync = () => {
    const nextSync = Date.now() + intervalMs;
    localStorage.setItem('smoobu_next_sync', nextSync.toString());
  };
  updateNextSync();
  
  // Check if sync is overdue (for when tab was inactive)
  const checkAndSync = async () => {
    if (!smoobuConfig.connected || !smoobuConfig.apiKey) return;
    
    const nextSync = parseInt(localStorage.getItem('smoobu_next_sync')) || 0;
    const now = Date.now();
    
    if (now >= nextSync) {
      console.log('Auto-sync running (was due)...');
      try {
        await syncSmoobuSilent();
        updateNextSync();
      } catch (e) {
        console.error('Auto-sync error:', e);
      }
    }
  };
  
  // Run sync on visibility change (when tab becomes active)
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      checkAndSync();
    }
  });
  
  // Also check on window focus
  window.addEventListener('focus', checkAndSync);
  
  // Regular interval (works when tab is active)
  smoobuConfig.syncInterval = setInterval(async () => {
    if (smoobuConfig.connected && smoobuConfig.apiKey) {
      console.log('Auto-sync Smoobu running...');
      try {
        await syncSmoobuSilent();
        updateNextSync();
      } catch (e) {
        console.error('Auto-sync error:', e);
      }
    }
  }, intervalMs);
  
  // Check immediately if sync is overdue
  setTimeout(checkAndSync, 2000);
}

// Silent sync (no modals, just background update)
async function syncSmoobuSilent() {
  try {
    // Sync Apartments
    const apartmentsRes = await fetch(`${SMOOBU_PROXY_URL}?action=apartments`, {
      headers: { 'x-smoobu-key': smoobuConfig.apiKey }
    });
    const apartmentsData = await apartmentsRes.json();
    
    if (apartmentsData.apartments) {
      smoobuConfig.smoobuApartments = apartmentsData.apartments;
      
      for (const apt of apartmentsData.apartments) {
        try {
          const detailRes = await fetch(`${SMOOBU_PROXY_URL}?action=apartment&id=${apt.id}`, {
            headers: { 'x-smoobu-key': smoobuConfig.apiKey }
          });
          const detail = await detailRes.json();
          
          const { data: existingProps } = await db.from('properties')
            .select('id, city, zip, street, bedrooms, max_guests, base_price')
            .eq('smoobu_id', apt.id)
            .limit(1);
          
          const existing = existingProps && existingProps.length > 0 ? existingProps[0] : null;
          
          if (existing) {
            // Update - preserve user-edited fields
            const propertyData = {
              host_id: user.id,
              smoobu_id: apt.id,
              name: apt.name,
              city: existing.city || detail.location?.city || '',
              zip: existing.zip || detail.location?.zip || '',
              street: existing.street || detail.location?.street || '',
              country: detail.location?.country || '',
              bedrooms: existing.bedrooms || detail.rooms?.bedrooms || 1,
              max_guests: existing.max_guests || detail.rooms?.maxOccupancy || 2,
              base_price: existing.base_price || (detail.price?.minimal ? parseFloat(detail.price.minimal) : null),
              property_type: 'apartment',
              active: true
            };
            await db.from('properties').update(propertyData).eq('id', existing.id);
          } else {
            // Insert new
            const propertyData = {
              host_id: user.id,
              smoobu_id: apt.id,
              name: apt.name,
              city: detail.location?.city || '',
              zip: detail.location?.zip || '',
              street: detail.location?.street || '',
              country: detail.location?.country || '',
              bedrooms: detail.rooms?.bedrooms || 1,
              max_guests: detail.rooms?.maxOccupancy || 2,
              base_price: detail.price?.minimal ? parseFloat(detail.price.minimal) : null,
              property_type: 'apartment',
              active: true
            };
            await db.from('properties').insert(propertyData);
          }
        } catch (e) {
          console.error('Silent sync property error:', apt.id, e);
        }
      }
    }
    
    // Sync Bookings
    const bookingsRes = await fetch(`${SMOOBU_PROXY_URL}?action=bookings`, {
      headers: { 'x-smoobu-key': smoobuConfig.apiKey }
    });
    const bookingsData = await bookingsRes.json();
    
    if (bookingsData.bookings && bookingsData.bookings.length > 0) {
      for (const booking of bookingsData.bookings) {
        try {
          const { data: localProps } = await db.from('properties')
            .select('id')
            .eq('smoobu_id', booking.apartment?.id)
            .limit(1);
          
          const localProp = localProps && localProps.length > 0 ? localProps[0] : null;
          
          if (localProp) {
            const { data: existingBookings } = await db.from('bookings')
              .select('id')
              .eq('smoobu_id', booking.id)
              .limit(1);
            
            const existingBooking = existingBookings && existingBookings.length > 0 ? existingBookings[0] : null;
            
            const bookingData = {
              host_id: user.id,
              property_id: localProp.id,
              smoobu_id: booking.id,
              guest_name: booking['guest-name'] || 'Unbekannt',
              guest_email: booking.email || '',
              guest_phone: booking.phone || '',
              check_in: booking.arrival,
              check_out: booking.departure,
              total_price: booking.price || 0,
              adults: booking.adults || 1,
              children: booking.children || 0,
              status: booking.type === 'cancellation' ? 'cancelled' : 'confirmed',
              source: booking.channel?.name || 'Smoobu'
            };
            
            if (existingBooking) {
              await db.from('bookings').update(bookingData).eq('id', existingBooking.id);
            } else {
              await db.from('bookings').insert(bookingData);
            }
          }
        } catch (e) {
          console.error('Silent sync booking error:', booking.id, e);
        }
      }
    }
    
    // Update last sync time
    smoobuConfig.lastSync = new Date().toISOString();
    localStorage.setItem('smoobu_last_sync', smoobuConfig.lastSync);
    
    // Save lastSync to Supabase for cross-device sync
    try {
      await db.from('profiles').update({
        smoobu_last_sync: smoobuConfig.lastSync
      }).eq('id', user.id);
    } catch (e) {
      console.log('Could not save lastSync to Supabase:', e);
    }
    
    // Reload data
    await loadData();
    
    // AUTO-PRICING: If mode is "auto", automatically upload optimized prices to Smoobu
    if (automationSettings.autoPricing && automationSettings.autoPricingMode === 'auto') {
      await autoUploadPricesToSmoobu();
    }
    
    // Update UI if on dashboard
    if (currentPage === 'dashboard' || currentPage === 'automation') {
      renderPage();
    }
    
    console.log('Auto-sync completed:', new Date().toLocaleTimeString());
    
  } catch (error) {
    console.error('Silent sync error:', error);
  }
}

// Automatically upload all optimized prices to Smoobu (when auto mode is enabled)
async function autoUploadPricesToSmoobu() {
  if (!smoobuConfig.connected || !smoobuConfig.apiKey) return;
  if (!pricingData.properties || pricingData.properties.length === 0) return;
  
  console.log('ü§ñ Auto-Pricing: Uploading optimized prices to Smoobu...');
  
  let totalUpdated = 0;
  let totalErrors = 0;
  
  for (const prop of pricingData.properties) {
    const dailyPrices = pricingData.dailyPrices[prop.id];
    if (!dailyPrices || dailyPrices.length === 0) continue;
    
    // Filter: only days that are not booked and not already applied
    const daysToUpdate = dailyPrices.filter(d => !d.isBooked && !d.applied);
    
    if (daysToUpdate.length === 0) {
      console.log(`‚úÖ ${prop.name}: All prices already synced`);
      continue;
    }
    
    console.log(`üì§ ${prop.name}: Uploading ${daysToUpdate.length} prices...`);
    
    // Batch update - send multiple dates at once for efficiency
    const batchSize = 10;
    for (let i = 0; i < daysToUpdate.length; i += batchSize) {
      const batch = daysToUpdate.slice(i, i + batchSize);
      
      const requestBody = {
        apartments: [parseInt(prop.id)],
        operations: batch.map(day => ({
          dates: [day.date],
          daily_price: day.finalPrice
        }))
      };
      
      try {
        const response = await fetch(`${SMOOBU_PROXY_URL}?action=update-rates`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-smoobu-key': smoobuConfig.apiKey
          },
          body: JSON.stringify(requestBody)
        });
        
        if (response.ok) {
          // Mark as applied
          batch.forEach(day => day.applied = true);
          totalUpdated += batch.length;
        } else {
          const errorData = await response.json().catch(() => ({}));
          console.error(`Error uploading prices for ${prop.name}:`, errorData);
          totalErrors += batch.length;
        }
      } catch (error) {
        console.error(`Network error uploading prices for ${prop.name}:`, error);
        totalErrors += batch.length;
      }
      
      // Small delay between batches to avoid rate limiting
      await new Promise(r => setTimeout(r, 200));
    }
  }
  
  if (totalUpdated > 0) {
    console.log(`‚úÖ Auto-Pricing: ${totalUpdated} prices uploaded to Smoobu`);
    showToast(`ü§ñ Auto-Pricing: ${totalUpdated} Preise zu Smoobu √ºbertragen`);
  }
  
  if (totalErrors > 0) {
    console.warn(`‚ö†Ô∏è Auto-Pricing: ${totalErrors} prices failed to upload`);
  }
}

function stopSmoobuAutoSync() {
  if (smoobuConfig.syncInterval) {
    clearInterval(smoobuConfig.syncInterval);
    smoobuConfig.syncInterval = null;
    console.log('Auto-sync stopped');
  }
}

// =====================
// MESSAGE POLLING & AUTO-REPLY SYSTEM
// =====================

let messagePollingInterval = null;
let lastKnownMessages = {}; // reservationId -> lastMessageId
let pendingAutoReplies = []; // Messages waiting for manual approval

// Load last known messages from localStorage
function loadLastKnownMessages() {
  try {
    const saved = localStorage.getItem('pilotstay_last_known_messages');
    if (saved) {
      lastKnownMessages = JSON.parse(saved);
      console.log('üìö Loaded lastKnownMessages:', Object.keys(lastKnownMessages).length, 'bookings');
    }
  } catch (e) {
    console.error('Error loading lastKnownMessages:', e);
    lastKnownMessages = {};
  }
}

// Save last known messages to localStorage
function saveLastKnownMessages() {
  try {
    localStorage.setItem('pilotstay_last_known_messages', JSON.stringify(lastKnownMessages));
  } catch (e) {
    console.error('Error saving lastKnownMessages:', e);
  }
}

// Debug function - call from console: debugAutoReply()
window.debugAutoReply = function() {
  console.log('========== AUTO-REPLY DEBUG ==========');
  console.log('üîó Smoobu connected:', smoobuConfig.connected);
  console.log('üîë API Key present:', !!smoobuConfig.apiKey);
  console.log('ü§ñ Smart Replies enabled:', automationSettings.smartReplies);
  console.log('‚öôÔ∏è Mode:', automationSettings.smartRepliesMode || 'manual');
  console.log('üìä Polling active:', !!messagePollingInterval);
  console.log('üìö Known message IDs:', Object.keys(lastKnownMessages).length, 'bookings');
  console.log('üí¨ Active chats:', chats.length);
  console.log('üìã Active bookings with smoobu_id:', bookings.filter(b => b.smoobu_id).length);
  
  // Check conditions
  const issues = [];
  if (!smoobuConfig.connected) issues.push('‚ùå Smoobu nicht verbunden');
  if (!smoobuConfig.apiKey) issues.push('‚ùå API Key fehlt');
  if (!automationSettings.smartReplies) issues.push('‚ùå Smart Replies deaktiviert');
  if (automationSettings.smartRepliesMode === 'off') issues.push('‚ùå Mode ist OFF');
  if (!messagePollingInterval) issues.push('‚ùå Polling l√§uft nicht');
  if (bookings.filter(b => b.smoobu_id).length === 0) issues.push('‚ùå Keine Buchungen mit Smoobu ID');
  
  if (issues.length === 0) {
    console.log('‚úÖ Alles OK - Auto-Reply sollte funktionieren');
    console.log('   ‚Üí Warte auf neue G√§stenachrichten...');
  } else {
    console.log('‚ö†Ô∏è Probleme gefunden:');
    issues.forEach(i => console.log('  ', i));
  }
  
  console.log('======================================');
  return { smoobuConfig, automationSettings, chats: chats.length, bookings: bookings.length };
};

// Start polling for new messages
function startMessagePolling() {
  if (messagePollingInterval) {
    clearInterval(messagePollingInterval);
  }
  
  // Load saved state
  loadLastKnownMessages();
  
  // Poll every 30 seconds for new messages
  const pollIntervalMs = 30 * 1000;
  
  console.log('‚úÖ Message polling started (every 30s)');
  console.log(`   Smart Replies: ${automationSettings.smartReplies ? 'ON' : 'OFF'}`);
  console.log(`   Mode: ${automationSettings.smartRepliesMode || 'manual'}`);
  
  // Initial poll after 5 seconds (give time for data to load)
  setTimeout(() => pollForNewMessages(), 5000);
  
  // Start interval
  messagePollingInterval = setInterval(() => {
    if (smoobuConfig.connected && smoobuConfig.apiKey) {
      pollForNewMessages();
    }
  }, pollIntervalMs);
}

function stopMessagePolling() {
  if (messagePollingInterval) {
    clearInterval(messagePollingInterval);
    messagePollingInterval = null;
    console.log('‚èπÔ∏è Message polling stopped');
  }
}

// Poll Smoobu for new messages across all reservations
async function pollForNewMessages() {
  if (!smoobuConfig.connected || !smoobuConfig.apiKey) {
    console.log('‚ùå Polling skipped: Smoobu not connected');
    return;
  }
  if (!automationSettings.smartReplies) {
    console.log('‚ùå Polling skipped: Smart Replies disabled');
    return;
  }
  
  console.log('üîç Polling for new messages...');
  
  try {
    // Get recent bookings (active ones with potential messages)
    const activeBookings = bookings.filter(b => {
      const checkout = new Date(b.check_out);
      const now = new Date();
      // Include bookings that checked out within last 7 days or future
      return checkout >= new Date(now - 7 * 24 * 60 * 60 * 1000) && b.status !== 'cancelled';
    });
    
    console.log(`üìã Checking ${Math.min(activeBookings.length, 10)} bookings for new messages`);
    
    let newMessagesFound = 0;
    
    for (const booking of activeBookings.slice(0, 10)) { // Limit to 10 to avoid rate limits
      if (!booking.smoobu_id) continue;
      
      try {
        const response = await fetch(
          `${SMOOBU_PROXY_URL}?action=messages&bookingId=${booking.smoobu_id}`,
          { headers: { 'x-smoobu-key': smoobuConfig.apiKey } }
        );
        
        if (!response.ok) continue;
        
        const data = await response.json();
        const messages = data.messages || data || [];
        
        if (!Array.isArray(messages) || messages.length === 0) continue;
        
        // Log message structure for debugging
        if (messages.length > 0 && !window._msgStructureLogged) {
          console.log('üìß Message structure sample:', JSON.stringify(messages[0], null, 2));
          window._msgStructureLogged = true;
        }
        
        // Check for new guest messages
        const lastKnown = lastKnownMessages[booking.smoobu_id] || '';
        
        // Better guest message detection - handle numeric type (2 = guest, 1 = host)
        const isGuestMessage = (m) => {
          // Safely convert to string
          const safeStr = (val) => val === null || val === undefined ? '' : String(val).toLowerCase();
          
          const typeVal = safeStr(m.type);
          const fromVal = safeStr(m.from);
          const dirVal = safeStr(m.direction);
          const senderVal = safeStr(m.sender);
          const sentByVal = safeStr(m.sent_by);
          
          // Smoobu uses type: 2 = Guest, 1 = Host
          return m.type === 2 || 
                 m.type === '2' ||
                 typeVal === 'guest' || 
                 typeVal === 'incoming' || 
                 typeVal === 'guesttohost' ||
                 fromVal === 'guest' || 
                 dirVal === 'in' ||
                 dirVal === 'incoming' ||
                 senderVal === 'guest' ||
                 sentByVal === 'guest';
        };
        
        // Use message ID as string for comparison (handles both numeric and string IDs)
        const newGuestMessages = messages.filter(m => {
          const msgId = String(m.id || '');
          const isNew = !lastKnown || msgId > lastKnown;
          const isFromGuest = isGuestMessage(m);
          
          if (isNew && isFromGuest) {
            console.log(`   üÜï New guest message detected: ID=${msgId}, type=${m.type}, from=${m.from}`);
          }
          
          return isNew && isFromGuest;
        });
        
        // Update last known message (use max ID as string)
        const allIds = messages.map(m => String(m.id || '0'));
        const maxId = allIds.sort().pop() || '0';
        lastKnownMessages[booking.smoobu_id] = maxId;
        
        // Process new messages
        for (const msg of newGuestMessages) {
          newMessagesFound++;
          console.log(`üì® New message from ${booking.guest_name}: "${(msg.message || msg.text || '').substring(0, 50)}..."`);
          await handleNewGuestMessage(booking, msg);
        }
        
      } catch (e) {
        console.error('Error polling messages for booking', booking.smoobu_id, e);
      }
      
      // Small delay between bookings to avoid rate limits
      await new Promise(r => setTimeout(r, 200));
    }
    
    if (newMessagesFound > 0) {
      console.log(`‚úÖ Found ${newMessagesFound} new message(s)`);
    }
    
    // Save updated lastKnownMessages
    saveLastKnownMessages();
    
  } catch (error) {
    console.error('Message polling error:', error);
  }
}

// Handle a new guest message
async function handleNewGuestMessage(booking, message) {
  const messageText = message.message || message.text || message.body || '';
  const guestName = booking.guest_name || 'Gast';
  
  console.log(`üì© Processing message from ${guestName}: "${messageText.substring(0, 50)}..."`);
  console.log(`   Mode: ${automationSettings.smartRepliesMode || 'manual'}`);
  
  // Find property for context
  const property = properties.find(p => p.id === booking.property_id);
  const propertyContext = property ? aiContext.properties[property.smoobu_id || property.id] : null;
  
  // Update local chat data
  let chat = chats.find(c => c.smoobuId === booking.smoobu_id || c.bookingId === booking.smoobu_id);
  if (!chat) {
    // Create new chat entry
    console.log(`   Creating new chat entry for ${guestName}`);
    chat = {
      id: booking.smoobu_id,
      bookingId: booking.smoobu_id,
      smoobuId: booking.smoobu_id,
      name: guestName,
      avatar: guestName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase(),
      platform: booking.source?.toLowerCase().includes('airbnb') ? 'airbnb' : 
                booking.source?.toLowerCase().includes('booking') ? 'booking' : 'direct',
      property: property?.name || 'Unbekannt',
      checkIn: booking.check_in,
      checkOut: booking.check_out,
      unread: 0,
      lastMsg: '',
      time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}),
      propertyId: property?.id,
      messages: []
    };
    chats.unshift(chat);
  }
  
  // Add message to chat
  const newMsg = {
    id: 'smoobu_' + message.id,
    from: 'them',
    text: messageText,
    time: new Date(message.created_at || Date.now()).toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}),
    timestamp: message.created_at || new Date().toISOString(),
    smoobuId: message.id
  };
  
  // Check if message already exists
  if (!chat.messages.find(m => m.id === newMsg.id)) {
    chat.messages.push(newMsg);
    chat.unread++;
    chat.lastMsg = messageText.substring(0, 50);
    chat.time = newMsg.time;
    console.log(`   Added message to chat (now ${chat.messages.length} messages)`);
  } else {
    console.log(`   Message already exists, skipping`);
    return;
  }
  
  // Determine action based on mode
  const mode = automationSettings.smartRepliesMode || 'manual';
  const isSimple = isSimpleQuestion(messageText);
  console.log(`   Question type: ${isSimple ? 'SIMPLE' : 'COMPLEX'}`);
  
  if (mode === 'manual') {
    console.log(`   Mode=manual ‚Üí Just notification`);
    showNotification(`üí¨ ${guestName}`, messageText.substring(0, 100));
    renderPage();
    return;
  }
  
  if (mode === 'hybrid' && !isSimple) {
    console.log(`   Mode=hybrid + COMPLEX ‚Üí Manual approval needed`);
    showNotification(`‚ö†Ô∏è Manuelle Pr√ºfung`, `${guestName}: ${messageText.substring(0, 80)}`);
    
    // Add to pending queue
    pendingAutoReplies.push({
      booking,
      message: newMsg,
      chat,
      property,
      timestamp: Date.now()
    });
    
    renderPage();
    return;
  }
  
  // Auto mode or simple question in hybrid mode - generate and send reply
  console.log(`   Mode=${mode} ‚Üí Generating auto-reply...`);
  try {
    showNotification('ü§ñ Generiere Antwort...', guestName);
    
    const reply = await generateAutoReplyForMessage(chat, newMsg, property, propertyContext);
    
    if (reply) {
      // Send via Smoobu
      const sendResult = await sendMessageViaSmoobu(booking.smoobu_id, reply);
      
      if (sendResult.success) {
        // Add to local chat
        const replyMsg = {
          id: 'auto_' + Date.now(),
          from: 'me',
          text: reply,
          time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}),
          ai: true,
          autoSent: true,
          needsFeedback: automationSettings.aiLearning
        };
        
        chat.messages.push(replyMsg);
        chat.lastMsg = reply;
        chat.unread = 0;
        
        showNotification('‚úÖ Auto-Reply gesendet', `An ${guestName}`);
        console.log(`Auto-reply sent to ${guestName}: ${reply.substring(0, 50)}...`);
        
        // Track for learning
        if (automationSettings.aiLearning) {
          trackAiUsage({
            type: 'auto-reply',
            guestMessage: messageText,
            aiResponse: reply,
            used: true,
            autoSent: true,
            timestamp: new Date().toISOString()
          });
        }
      } else {
        console.error('Failed to send auto-reply:', sendResult.error);
        showNotification('‚ùå Senden fehlgeschlagen', sendResult.error);
      }
    }
    
  } catch (error) {
    console.error('Auto-reply error:', error);
    showNotification('‚ùå KI-Fehler', error.message);
  }
  
  renderPage();
}

// Generate auto-reply for a message
async function generateAutoReplyForMessage(chat, message, property, propertyContext) {
  // Get conversation history
  const history = chat.messages.slice(-6).map(m => m.text);
  
  // Build context
  let contextInfo = '';
  if (property) {
    contextInfo = `Objekt: ${property.name}\n`;
    if (propertyContext) {
      if (propertyContext.wifi) contextInfo += `WLAN: ${propertyContext.wifi}\n`;
      if (propertyContext.parking) contextInfo += `Parkplatz: ${propertyContext.parking}\n`;
      if (propertyContext.checkin) contextInfo += `Check-in: ${propertyContext.checkin}\n`;
      if (propertyContext.checkout) contextInfo += `Check-out: ${propertyContext.checkout}\n`;
      if (propertyContext.houseRules) contextInfo += `Hausregeln: ${propertyContext.houseRules}\n`;
    }
  }
  
  try {
    const session = await db.auth.getSession();
    const token = session?.data?.session?.access_token || '';
    
    const response = await fetch(AI_PROXY_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + token
      },
      body: JSON.stringify({
        action: 'auto-reply',
        data: {
          guestName: chat.name,
          guestMessage: message.text,
          conversationHistory: history,
          propertyContext: contextInfo,
          tone: automationSettings.aiTone || 'friendly',
          language: automationSettings.aiLanguage || 'de'
        }
      })
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'AI request failed');
    }
    
    const data = await response.json();
    return data.reply;
    
  } catch (error) {
    console.error('Generate auto-reply error:', error);
    
    // Fallback to simple response
    return getSimpleFallbackReply(message.text);
  }
}

// Simple fallback reply if AI fails
function getSimpleFallbackReply(messageText) {
  const text = messageText.toLowerCase();
  
  if (text.includes('wifi') || text.includes('wlan') || text.includes('internet')) {
    const ctx = Object.values(aiContext.properties)[0];
    if (ctx?.wifi) return `Das WLAN-Passwort ist: ${ctx.wifi} üì∂`;
    return 'Die WLAN-Zugangsdaten findest du in der Wohnung - ich schicke sie dir gleich! üì∂';
  }
  
  if (text.includes('check-in') || text.includes('checkin') || text.includes('ankommen')) {
    const ctx = Object.values(aiContext.properties)[0];
    if (ctx?.checkin) return `Check-in ist ab ${ctx.checkin}. Ich melde mich wenn alles bereit ist! üîë`;
    return 'Check-in ist ab 15:00 Uhr. Ich melde mich rechtzeitig! üîë';
  }
  
  if (text.includes('checkout') || text.includes('abreise')) {
    const ctx = Object.values(aiContext.properties)[0];
    if (ctx?.checkout) return `Check-out ist bis ${ctx.checkout}. Gute Heimreise! üëã`;
    return 'Check-out ist bis 11:00 Uhr. Gute Heimreise! üëã';
  }
  
  if (text.includes('danke') || text.includes('super') || text.includes('toll')) {
    return 'Freut mich sehr! Bei Fragen einfach melden. üòä';
  }
  
  // Default - don't auto-reply with generic message
  return null;
}

// Send message via Smoobu API
async function sendMessageViaSmoobu(reservationId, messageText) {
  try {
    const response = await fetch(`${SMOOBU_PROXY_URL}?action=send-message`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-smoobu-key': smoobuConfig.apiKey
      },
      body: JSON.stringify({
        bookingId: reservationId,
        messageBody: messageText
      })
    });
    
    if (response.ok) {
      return { success: true };
    } else {
      const error = await response.json();
      return { success: false, error: error.message || 'Senden fehlgeschlagen' };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// Show browser notification
function showNotification(title, body) {
  // Show in-app toast
  showToast(`${title}: ${body}`);
  
  // Try browser notification if permitted
  if ('Notification' in window && Notification.permission === 'granted') {
    new Notification(title, { body, icon: 'üè†' });
  }
}

// Request notification permission
function requestNotificationPermission() {
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission().then(permission => {
      if (permission === 'granted') {
        showToast('‚úÖ Benachrichtigungen aktiviert');
      }
    });
  }
}

// View pending auto-replies (for hybrid mode)
function showPendingReplies() {
  if (pendingAutoReplies.length === 0) {
    showToast('‚úÖ Keine ausstehenden Nachrichten');
    return;
  }
  
  const list = pendingAutoReplies.map((item, idx) => `
    <div class="card" style="margin-bottom:12px">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <div style="font-weight:600">${item.chat.name}</div>
          <div style="font-size:11px;color:#71717a">${item.property?.name || 'Unbekanntes Objekt'}</div>
        </div>
        <span class="tag tag-orange">Ausstehend</span>
      </div>
      <div style="background:#18181b;padding:10px;border-radius:8px;font-size:13px;margin-bottom:12px">
        "${item.message.text}"
      </div>
      <div style="display:flex;gap:8px">
        <button class="btn btn-sm btn-ai" onclick="approvePendingReply(${idx})">ü§ñ KI antworten</button>
        <button class="btn btn-sm btn-secondary" onclick="openChatForPending(${idx})">‚úèÔ∏è Manuell</button>
        <button class="btn btn-sm btn-secondary" onclick="dismissPendingReply(${idx})" style="color:#ef4444">‚úï</button>
      </div>
    </div>
  `).join('');
  
  showModal(`
    <div class="modal-title">‚ö†Ô∏è Ausstehende Nachrichten (${pendingAutoReplies.length})</div>
    <div style="font-size:13px;color:#a1a1aa;margin-bottom:16px">
      Diese Nachrichten brauchen deine Pr√ºfung (Hybrid-Modus)
    </div>
    <div style="max-height:400px;overflow-y:auto">
      ${list}
    </div>
    <button class="btn btn-secondary" onclick="hideModal()" style="width:100%;margin-top:12px">Schlie√üen</button>
  `);
}

async function approvePendingReply(idx) {
  const item = pendingAutoReplies[idx];
  if (!item) return;
  
  hideModal();
  showToast('ü§ñ Generiere Antwort...');
  
  const propertyContext = item.property ? aiContext.properties[item.property.smoobu_id || item.property.id] : null;
  const reply = await generateAutoReplyForMessage(item.chat, item.message, item.property, propertyContext);
  
  if (reply) {
    // Show for approval before sending
    showModal(`
      <div class="modal-title">ü§ñ KI-Antwort pr√ºfen</div>
      <div style="margin-bottom:12px">
        <div style="font-size:12px;color:#71717a">Nachricht von ${item.chat.name}:</div>
        <div style="background:#18181b;padding:10px;border-radius:8px;font-size:13px;margin-top:4px">"${item.message.text}"</div>
      </div>
      <div style="margin-bottom:16px">
        <div style="font-size:12px;color:#71717a">KI-Antwort:</div>
        <textarea id="pending-reply-text" class="input" style="min-height:100px;margin-top:4px">${reply}</textarea>
      </div>
      <div style="display:flex;gap:12px">
        <button class="btn btn-secondary" onclick="hideModal();showPendingReplies()" style="flex:1">Zur√ºck</button>
        <button class="btn btn-ai" onclick="sendApprovedReply(${idx})" style="flex:1">üì§ Senden</button>
      </div>
    `);
  } else {
    showToast('‚ùå Konnte keine Antwort generieren');
    showPendingReplies();
  }
}

async function sendApprovedReply(idx) {
  const item = pendingAutoReplies[idx];
  if (!item) return;
  
  const replyText = document.getElementById('pending-reply-text').value.trim();
  if (!replyText) return;
  
  hideModal();
  
  const result = await sendMessageViaSmoobu(item.booking.smoobu_id, replyText);
  
  if (result.success) {
    // Add to chat
    item.chat.messages.push({
      id: 'approved_' + Date.now(),
      from: 'me',
      text: replyText,
      time: new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'}),
      ai: true
    });
    item.chat.unread = 0;
    item.chat.lastMsg = replyText;
    
    // Remove from pending
    pendingAutoReplies.splice(idx, 1);
    
    showToast('‚úÖ Nachricht gesendet!');
  } else {
    showToast('‚ùå Senden fehlgeschlagen: ' + result.error);
  }
  
  renderPage();
}

function openChatForPending(idx) {
  const item = pendingAutoReplies[idx];
  if (!item) return;
  
  hideModal();
  activeChat = item.chat.id;
  setPage('chat');
  
  // Remove from pending
  pendingAutoReplies.splice(idx, 1);
}

function dismissPendingReply(idx) {
  pendingAutoReplies.splice(idx, 1);
  if (pendingAutoReplies.length === 0) {
    hideModal();
  } else {
    showPendingReplies();
  }
}

function getSyncIntervalDisplay() {
  const interval = localStorage.getItem('smoobu_sync_interval') || '5';
  if (interval === '1') return '1 Min';
  if (interval === '60') return '1 Std';
  return interval + ' Min';
}

function showSmoobuSettings() {
  const currentInterval = localStorage.getItem('smoobu_sync_interval') || '5';
  
  showModal(`
    <div class="modal-title">‚öôÔ∏è Smoobu Einstellungen</div>
    
    <div style="margin-bottom:20px">
      <label class="label">Sync-Intervall</label>
      <select class="input" id="sync-interval">
        <option value="1" ${currentInterval === '1' ? 'selected' : ''}>Jede Minute</option>
        <option value="5" ${currentInterval === '5' ? 'selected' : ''}>Alle 5 Minuten</option>
        <option value="15" ${currentInterval === '15' ? 'selected' : ''}>Alle 15 Minuten</option>
        <option value="30" ${currentInterval === '30' ? 'selected' : ''}>Alle 30 Minuten</option>
        <option value="60" ${currentInterval === '60' ? 'selected' : ''}>St√ºndlich</option>
      </select>
      <div style="font-size:11px;color:#71717a;margin-top:6px">
        Automatische Synchronisierung mit Smoobu im Hintergrund
      </div>
    </div>
    
    <div style="margin-bottom:20px">
      <label class="label">Was synchronisieren?</label>
      <div style="display:flex;flex-direction:column;gap:12px;margin-top:8px">
        <label style="display:flex;align-items:center;gap:10px;cursor:pointer">
          <input type="checkbox" id="sync-properties" checked> <span>Objekte/Apartments</span>
        </label>
        <label style="display:flex;align-items:center;gap:10px;cursor:pointer">
          <input type="checkbox" id="sync-bookings" checked> <span>Buchungen</span>
        </label>
        <label style="display:flex;align-items:center;gap:10px;cursor:pointer">
          <input type="checkbox" id="sync-prices" checked> <span>Preise/Raten</span>
        </label>
      </div>
    </div>
    
    <div style="padding:12px;background:#18181b;border-radius:10px;margin-bottom:20px">
      <div style="font-size:12px;color:#71717a">API-Key (versteckt)</div>
      <div style="font-family:monospace;font-size:13px;margin-top:4px">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢${smoobuConfig.apiKey.slice(-8)}</div>
    </div>
    
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
      <button class="btn btn-primary" onclick="saveSmoobuSettings()" style="flex:1">üíæ Speichern</button>
    </div>
  `);
}

async function saveSmoobuSettings() {
  // Save sync interval
  const interval = document.getElementById('sync-interval').value;
  localStorage.setItem('smoobu_sync_interval', interval);
  
  // Save to Supabase
  try {
    await db.from('profiles').update({
      smoobu_sync_interval: parseInt(interval)
    }).eq('id', user.id);
  } catch (e) {
    console.log('Could not save interval to Supabase:', e);
  }
  
  // Restart auto-sync with new interval
  startSmoobuAutoSync();
  
  hideModal();
  showToast(`‚úÖ Sync-Intervall auf ${interval === '1' ? '1 Minute' : interval + ' Minuten'} gesetzt`);
  renderPage();
}

function showToast(message) {
  const toast = document.createElement('div');
  toast.style.cssText = 'position:fixed;bottom:24px;right:24px;background:#22c55e;color:#fff;padding:12px 20px;border-radius:10px;font-size:14px;font-weight:600;z-index:9999;animation:slideIn .3s ease';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), 3000);
}

// Check Smoobu connection on load
function checkSmoobuConnection() {
  const connected = localStorage.getItem('smoobu_connected') === 'true';
  const apiKey = localStorage.getItem('smoobu_api_key');
  const lastSync = localStorage.getItem('smoobu_last_sync');
  
  if (connected && apiKey) {
    smoobuConfig.connected = true;
    smoobuConfig.apiKey = apiKey;
    smoobuConfig.lastSync = lastSync;
    startSmoobuAutoSync();
    
    // Start message polling for auto-replies
    if (automationSettings.smartReplies) {
      startMessagePolling();
      requestNotificationPermission();
    }
  }
}

function renderSettings() {
  return `
    <div class="card">
      <div class="card-title">üë§ Profil</div>
      <div class="grid-2" style="gap:16px;margin-bottom:20px">
        <div><label class="label">Vorname</label><input class="input" value="${profile?.first_name || ''}" id="s-fn"></div>
        <div><label class="label">Nachname</label><input class="input" value="${profile?.last_name || ''}" id="s-ln"></div>
      </div>
      <div style="margin-bottom:20px">
        <label class="label">E-Mail</label>
        <input class="input" value="${user?.email || ''}" disabled style="opacity:0.6">
      </div>
      <div style="margin-bottom:20px">
        <label class="label">Telefon</label>
        <input class="input" value="${profile?.phone || ''}" placeholder="+49 123 456789" id="s-ph">
      </div>
      <button class="btn btn-primary" onclick="saveProfile()">üíæ Speichern</button>
    </div>
    
    <div class="card" style="margin-top:16px">
      <div class="card-title">üéì Hilfe & Tutorial</div>
      <div style="color:#a1a1aa;font-size:13px;margin-bottom:16px">
        M√∂chtest du das interaktive Tutorial nochmal durchlaufen?
      </div>
      <button class="btn btn-secondary" onclick="resetTutorial()">
        üîÑ Tutorial erneut starten
      </button>
    </div>
    
    <div class="card" style="margin-top:16px">
      <div class="card-title">‚ö†Ô∏è Gefahrenzone</div>
      <div style="color:#a1a1aa;font-size:13px;margin-bottom:16px">
        Achtung: Diese Aktionen k√∂nnen nicht r√ºckg√§ngig gemacht werden.
      </div>
      <button class="btn btn-secondary" style="color:#ef4444" onclick="confirmLogout()">
        üö™ Abmelden
      </button>
    </div>
  `;
}

function confirmLogout() {
  showModal(`
    <div style="text-align:center;padding:20px">
      <div style="font-size:48px;margin-bottom:16px">üëã</div>
      <div style="font-size:18px;font-weight:700;margin-bottom:8px">Wirklich abmelden?</div>
      <div style="color:#a1a1aa;margin-bottom:24px">Du kannst dich jederzeit wieder anmelden.</div>
      <div style="display:flex;gap:12px">
        <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
        <button class="btn btn-primary" onclick="doLogout()" style="flex:1">Abmelden</button>
      </div>
    </div>
  `);
}

async function doLogout() {
  await db.auth.signOut();
  window.location.href = 'auth.html';
}

// =====================
// MODALS
// =====================
function showModal(html) {
  document.getElementById('modal-content').innerHTML = html;
  document.getElementById('modal').style.display = 'flex';
}

function hideModal() {
  document.getElementById('modal').style.display = 'none';
}

function showAddProp() {
  showModal('<div class="modal-title">üè† Neues Objekt</div><div style="margin-bottom:16px"><label class="label">Name *</label><input class="input" id="p-name" placeholder="z.B. Gem√ºtliche Wohnung"></div><div class="grid-2" style="gap:12px;margin-bottom:16px"><div><label class="label">Stadt</label><input class="input" id="p-city" placeholder="Berlin"></div><div><label class="label">PLZ</label><input class="input" id="p-zip" placeholder="10115"></div></div><div class="grid-2" style="gap:12px;margin-bottom:16px"><div><label class="label">Schlafzimmer</label><input class="input" type="number" id="p-bed" value="1" min="1"></div><div><label class="label">Max G√§ste</label><input class="input" type="number" id="p-guests" value="2" min="1"></div></div><div style="margin-bottom:20px"><label class="label">Preis/Nacht (‚Ç¨)</label><input class="input" type="number" id="p-price" placeholder="80"></div><div style="display:flex;gap:12px"><button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button><button class="btn btn-primary" onclick="addProp()" style="flex:1">‚úì Anlegen</button></div>');
}

async function addProp() {
  const name = document.getElementById('p-name').value.trim();
  if (!name) { alert('Bitte Namen eingeben'); return; }
  const {data, error} = await db.from('properties').insert({host_id:user.id, name, city:document.getElementById('p-city').value.trim(), zip:document.getElementById('p-zip').value.trim(), bedrooms:parseInt(document.getElementById('p-bed').value)||1, max_guests:parseInt(document.getElementById('p-guests').value)||2, base_price:parseFloat(document.getElementById('p-price').value)||null, property_type:'apartment', active:true}).select().single();
  if (error) alert('Fehler: ' + error.message);
  else { properties.unshift(data); hideModal(); renderPage(); }
}

function showAddBook() {
  if (!properties.length) { alert('Bitte erst Objekt anlegen'); return; }
  showModal('<div class="modal-title">üìÖ Neue Buchung</div><div style="margin-bottom:16px"><label class="label">Objekt *</label><select class="input" id="b-prop">' + properties.map(p => '<option value="' + p.id + '">' + p.name + '</option>').join('') + '</select></div><div style="margin-bottom:16px"><label class="label">Gast *</label><input class="input" id="b-guest" placeholder="Max Mustermann"></div><div class="grid-2" style="gap:12px;margin-bottom:16px"><div><label class="label">Check-in</label><input class="input" type="date" id="b-in"></div><div><label class="label">Check-out</label><input class="input" type="date" id="b-out"></div></div><div style="margin-bottom:20px"><label class="label">Preis (‚Ç¨)</label><input class="input" type="number" id="b-price" placeholder="350"></div><div style="display:flex;gap:12px"><button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button><button class="btn btn-primary" onclick="addBook()" style="flex:1">‚úì Speichern</button></div>');
}

async function addBook() {
  const guest = document.getElementById('b-guest').value.trim();
  const ci = document.getElementById('b-in').value;
  const co = document.getElementById('b-out').value;
  if (!guest || !ci || !co) { alert('Bitte alle Felder ausf√ºllen'); return; }
  const {data, error} = await db.from('bookings').insert({host_id:user.id, property_id:document.getElementById('b-prop').value, guest_name:guest, check_in:ci, check_out:co, total_price:parseFloat(document.getElementById('b-price').value)||0, status:'confirmed', source:'manual'}).select('*,properties(name)').single();
  if (error) alert('Fehler: ' + error.message);
  else { bookings.unshift(data); hideModal(); renderPage(); }
}

// =====================
// EDIT & DELETE FUNCTIONS
// =====================

function editProperty(id) {
  const p = properties.find(prop => prop.id === id);
  if (!p) return;
  
  showModal(`
    <div class="modal-title">‚úèÔ∏è Objekt bearbeiten</div>
    <div style="margin-bottom:16px">
      <label class="label">Name *</label>
      <input class="input" id="ep-name" value="${p.name || ''}" placeholder="z.B. Gem√ºtliche Wohnung">
    </div>
    <div class="grid-2" style="gap:12px;margin-bottom:16px">
      <div><label class="label">Stadt</label><input class="input" id="ep-city" value="${p.city || ''}" placeholder="Berlin"></div>
      <div><label class="label">PLZ</label><input class="input" id="ep-zip" value="${p.zip || ''}" placeholder="10115"></div>
    </div>
    <div class="grid-2" style="gap:12px;margin-bottom:16px">
      <div><label class="label">Schlafzimmer</label><input class="input" type="number" id="ep-bed" value="${p.bedrooms || 1}" min="1"></div>
      <div><label class="label">Max G√§ste</label><input class="input" type="number" id="ep-guests" value="${p.max_guests || 2}" min="1"></div>
    </div>
    <div style="margin-bottom:16px">
      <label class="label">Preis/Nacht (‚Ç¨)</label>
      <input class="input" type="number" id="ep-price" value="${p.base_price || ''}" placeholder="80">
    </div>
    <div style="margin-bottom:20px">
      <label class="label">Status</label>
      <select class="input" id="ep-active">
        <option value="true" ${p.active !== false ? 'selected' : ''}>Aktiv</option>
        <option value="false" ${p.active === false ? 'selected' : ''}>Inaktiv</option>
      </select>
    </div>
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
      <button class="btn btn-primary" onclick="updateProperty('${id}')" style="flex:1">‚úì Speichern</button>
    </div>
  `);
}

async function updateProperty(id) {
  const name = document.getElementById('ep-name').value.trim();
  if (!name) { alert('Bitte Namen eingeben'); return; }
  
  const updateData = {
    name,
    city: document.getElementById('ep-city').value.trim(),
    zip: document.getElementById('ep-zip').value.trim(),
    bedrooms: parseInt(document.getElementById('ep-bed').value) || 1,
    max_guests: parseInt(document.getElementById('ep-guests').value) || 2,
    base_price: parseFloat(document.getElementById('ep-price').value) || null,
    active: document.getElementById('ep-active').value === 'true'
  };
  
  const {error} = await db.from('properties').update(updateData).eq('id', id);
  
  if (error) {
    alert('Fehler: ' + error.message);
  } else {
    // Update local data
    const idx = properties.findIndex(p => p.id === id);
    if (idx !== -1) properties[idx] = {...properties[idx], ...updateData};
    hideModal();
    showToast('‚úÖ Objekt aktualisiert');
    renderPage();
  }
}

async function deleteProperty(id) {
  const p = properties.find(prop => prop.id === id);
  if (!p) return;
  
  showModal(`
    <div style="text-align:center;padding:20px">
      <div style="font-size:48px;margin-bottom:16px">üóëÔ∏è</div>
      <div style="font-size:18px;font-weight:700;margin-bottom:8px">Objekt l√∂schen?</div>
      <div style="color:#a1a1aa;margin-bottom:8px">"${p.name}"</div>
      <div style="color:#ef4444;font-size:12px;margin-bottom:24px">
        ‚ö†Ô∏è Alle zugeh√∂rigen Buchungen werden ebenfalls gel√∂scht!
      </div>
      <div style="display:flex;gap:12px">
        <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
        <button class="btn btn-primary" onclick="confirmDeleteProperty('${id}')" style="flex:1;background:#ef4444">üóëÔ∏è L√∂schen</button>
      </div>
    </div>
  `);
}

async function confirmDeleteProperty(id) {
  // First delete related bookings
  await db.from('bookings').delete().eq('property_id', id);
  
  // Then delete property
  const {error} = await db.from('properties').delete().eq('id', id);
  
  if (error) {
    alert('Fehler: ' + error.message);
  } else {
    // Remove from local data
    properties = properties.filter(p => p.id !== id);
    bookings = bookings.filter(b => b.property_id !== id);
    hideModal();
    showToast('‚úÖ Objekt gel√∂scht');
    renderPage();
  }
}

function editBooking(id) {
  const b = bookings.find(book => book.id === id);
  if (!b) return;
  
  showModal(`
    <div class="modal-title">‚úèÔ∏è Buchung bearbeiten</div>
    <div style="margin-bottom:16px">
      <label class="label">Objekt *</label>
      <select class="input" id="eb-prop">
        ${properties.map(p => `<option value="${p.id}" ${p.id === b.property_id ? 'selected' : ''}>${p.name}</option>`).join('')}
      </select>
    </div>
    <div style="margin-bottom:16px">
      <label class="label">Gast *</label>
      <input class="input" id="eb-guest" value="${b.guest_name || ''}" placeholder="Max Mustermann">
    </div>
    <div class="grid-2" style="gap:12px;margin-bottom:16px">
      <div><label class="label">Check-in</label><input class="input" type="date" id="eb-in" value="${b.check_in || ''}"></div>
      <div><label class="label">Check-out</label><input class="input" type="date" id="eb-out" value="${b.check_out || ''}"></div>
    </div>
    <div class="grid-2" style="gap:12px;margin-bottom:16px">
      <div><label class="label">Preis (‚Ç¨)</label><input class="input" type="number" id="eb-price" value="${b.total_price || ''}" placeholder="350"></div>
      <div>
        <label class="label">Status</label>
        <select class="input" id="eb-status">
          <option value="confirmed" ${b.status === 'confirmed' ? 'selected' : ''}>Best√§tigt</option>
          <option value="cancelled" ${b.status === 'cancelled' ? 'selected' : ''}>Storniert</option>
        </select>
      </div>
    </div>
    <div style="display:flex;gap:12px">
      <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
      <button class="btn btn-primary" onclick="updateBooking('${id}')" style="flex:1">‚úì Speichern</button>
    </div>
  `);
}

async function updateBooking(id) {
  const guest = document.getElementById('eb-guest').value.trim();
  const ci = document.getElementById('eb-in').value;
  const co = document.getElementById('eb-out').value;
  
  if (!guest || !ci || !co) { alert('Bitte alle Felder ausf√ºllen'); return; }
  
  const updateData = {
    property_id: document.getElementById('eb-prop').value,
    guest_name: guest,
    check_in: ci,
    check_out: co,
    total_price: parseFloat(document.getElementById('eb-price').value) || 0,
    status: document.getElementById('eb-status').value
  };
  
  const {error} = await db.from('bookings').update(updateData).eq('id', id);
  
  if (error) {
    alert('Fehler: ' + error.message);
  } else {
    // Update local data
    const idx = bookings.findIndex(b => b.id === id);
    if (idx !== -1) {
      bookings[idx] = {...bookings[idx], ...updateData};
      // Update property name reference
      const prop = properties.find(p => p.id === updateData.property_id);
      if (prop) bookings[idx].properties = {name: prop.name};
    }
    hideModal();
    showToast('‚úÖ Buchung aktualisiert');
    renderPage();
  }
}

async function deleteBooking(id) {
  const b = bookings.find(book => book.id === id);
  if (!b) return;
  
  showModal(`
    <div style="text-align:center;padding:20px">
      <div style="font-size:48px;margin-bottom:16px">üóëÔ∏è</div>
      <div style="font-size:18px;font-weight:700;margin-bottom:8px">Buchung l√∂schen?</div>
      <div style="color:#a1a1aa;margin-bottom:8px">Gast: ${b.guest_name}</div>
      <div style="color:#71717a;font-size:12px;margin-bottom:24px">
        ${fmtDate(b.check_in)} - ${fmtDate(b.check_out)} ¬∑ ‚Ç¨${b.total_price || 0}
      </div>
      <div style="display:flex;gap:12px">
        <button class="btn btn-secondary" onclick="hideModal()" style="flex:1">Abbrechen</button>
        <button class="btn btn-primary" onclick="confirmDeleteBooking('${id}')" style="flex:1;background:#ef4444">üóëÔ∏è L√∂schen</button>
      </div>
    </div>
  `);
}

async function confirmDeleteBooking(id) {
  const {error} = await db.from('bookings').delete().eq('id', id);
  
  if (error) {
    alert('Fehler: ' + error.message);
  } else {
    // Remove from local data
    bookings = bookings.filter(b => b.id !== id);
    hideModal();
    showToast('‚úÖ Buchung gel√∂scht');
    renderPage();
  }
}

async function saveProfile() {
  const {error} = await db.from('profiles').update({first_name:document.getElementById('s-fn').value.trim(), last_name:document.getElementById('s-ln').value.trim(), phone:document.getElementById('s-ph').value.trim()}).eq('id', user.id);
  if (error) alert('Fehler: ' + error.message);
  else { alert('Gespeichert!'); const {data} = await db.from('profiles').select('*').eq('id', user.id).single(); profile = data; renderUser(); }
}

// =====================
// HELPERS
// =====================
function fmtDate(d) {
  return d ? new Date(d).toLocaleDateString('de-DE', {day:'2-digit', month:'2-digit', year:'numeric'}) : '-';
}

// =====================
// EVENTS
// =====================
function bindEvents() {
  document.querySelectorAll('.nav-item').forEach(i => i.onclick = () => setPage(i.dataset.page));
  document.getElementById('logout-btn').onclick = async () => { await db.auth.signOut(); window.location.href = 'auth.html'; };
  document.getElementById('modal').onclick = e => { if (e.target.id === 'modal') hideModal(); };
}

// =====================
// START
// =====================
init();
</script>
</body>
</html>
