// Supabase Edge Function: smoobu-proxy
// Full proxy for Smoobu + optional Ticketmaster. Includes permissive CORS for pilotstay.app.
// Actions supported:
// - me (GET)
// - apartments (GET)
// - bookings (GET)  [optional query params]
// - messages (GET)  [bookingId required]
// - send-message (POST) { bookingId, message/messageBody }
// - rates (POST/GET) { apartmentId, startDate, endDate }  (client can send JSON body or query)
// - ticketmaster (GET)  (query params forwarded)
//
// IMPORTANT:
// 1) Prefer server-side secret: SMOOBU_API_KEY in env.
// 2) If you still pass x-smoobu-key from the client, this function allows it (not recommended long-term).
//
// Deploy: supabase functions deploy smoobu-proxy

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";

const CORS_HEADERS = {
  "Access-Control-Allow-Origin": "https://pilotstay.app",
  "Access-Control-Allow-Credentials": "true",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type, x-smoobu-key, x-action",
  "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
  "Vary": "Origin",
};

const VERSION = "smoobu-proxy-v10";


function json(data: unknown, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "Content-Type": "application/json", "X-PilotStay-Proxy-Version": VERSION, ...CORS_HEADERS },
  });
}

function pickApiKey(req: Request) {
  // Prefer env var, fallback to client header (temporary).
  const envKey = Deno.env.get("SMOOBU_API_KEY");
  if (envKey && envKey.trim()) return envKey.trim();

  const headerKey = req.headers.get("x-smoobu-key");
  if (headerKey && headerKey.trim()) return headerKey.trim();

  return null;
}

async function smoobuFetch(req: Request, url: string, init?: RequestInit) {
  const apiKey = pickApiKey(req);
  if (!apiKey) return json({ error: "Missing Smoobu API key" }, 401);

  const headers: Record<string, string> = {
    "Api-Key": apiKey,
    "Content-Type": "application/json",
    ...(init?.headers ? Object.fromEntries(new Headers(init.headers).entries()) : {}),
  };

  const resp = await fetch(url, { ...init, headers });
  const text = await resp.text();
  let body: any = null;
  try { body = text ? JSON.parse(text) : null; } catch { body = text; }

  if (!resp.ok) {
    return json({ ok: false, status: resp.status, error: body ?? text }, resp.status);
  }
  return json({ ok: true, status: resp.status, result: body }, 200);
}

serve(async (req) => {
  if (req.method === "OPTIONS") return new Response(null, { status: 204, headers: CORS_HEADERS });

  const url = new URL(req.url);
  let parsedBody: any = null;
  // Parse JSON body at most once (safe for GET where body is empty)
  if (req.method !== "GET" && req.method !== "HEAD") {
    try { parsedBody = await req.json(); } catch { parsedBody = null; }
  }

  const action = (
    url.searchParams.get("action") ||
    req.headers.get("x-action") ||
    (parsedBody?.action ?? "")
  ).toString().trim();

  try {
    // -------------------------
    // Smoobu
    // -------------------------
    
  // Health check (no API key required)
  if (action === "health") {
    return json({
      ok: true,
      version: "v9",
      received: {
        action,
        queryAction: url.searchParams.get("action"),
        headerAction: req.headers.get("x-action"),
      },
      supportedActions: [
        "health","me","bookings","apartments","messages","send-message","rates","update-rates","ticketmaster"
      ],
    }, 200);
  }

if (action === "me") {
      // Basic auth check / account info
      return await smoobuFetch(req, "https://login.smoobu.com/api/me", { method: "GET" });
    }

    if (action === "apartments") {
      return await smoobuFetch(req, "https://login.smoobu.com/api/apartments", { method: "GET" });
    }

    if (action === "bookings") {
      // Forward optional filters
      const qs = new URLSearchParams();
      for (const k of ["from", "to", "apartmentId", "page", "pageSize", "sort"]) {
        const v = url.searchParams.get(k);
        if (v) qs.set(k, v);
      }
      const endpoint = `https://login.smoobu.com/api/bookings${qs.toString() ? "?" + qs.toString() : ""}`;
      return await smoobuFetch(req, endpoint, { method: "GET" });
    }

    if (action === "messages") {
      const bookingId = url.searchParams.get("bookingId");
      if (!bookingId) return json({ error: "bookingId required" }, 400);

      const page = url.searchParams.get("page") || "1";
      const pageSize = url.searchParams.get("page_size") || url.searchParams.get("pageSize") || "25";

      // Smoobu messages endpoint (booking conversation)
      const endpoint = `https://login.smoobu.com/api/bookings/${encodeURIComponent(bookingId)}/messages?page=${encodeURIComponent(page)}&page_size=${encodeURIComponent(pageSize)}`;
      return await smoobuFetch(req, endpoint, { method: "GET" });
    }

    if (action === "send-message") {
      if (req.method !== "POST") return json({ error: "send-message must be POST" }, 405);

      const body = (parsedBody ?? {});
      const bookingId = String(body.bookingId || "").trim();
      const messageBody = String(body.messageBody ?? body.message ?? "").trim();

      if (!bookingId || !messageBody) {
        return json({ error: "bookingId and messageBody required" }, 400);
      }

      const endpoint = `https://login.smoobu.com/api/bookings/${encodeURIComponent(bookingId)}/messages`;
      return await smoobuFetch(req, endpoint, {
        method: "POST",
        body: JSON.stringify({ messageBody }),
      });
    }

    if (action === "rates") {
      // This action is app-specific. It expects apartmentId + date range and returns Smoobu rates/calendar.
      // Some Smoobu accounts expose /api/rates or /api/apartments/{id}/rates; adjust if needed.
      // We implement BOTH patterns: try apartments/{id}/rates first, fallback to /rates.
      const body = (parsedBody ?? {});

      const apartmentId = String(body.apartmentId ?? body.apartment_id ?? url.searchParams.get("apartmentId") ?? url.searchParams.get("apartment_id") ?? "").trim();
      const startDate = String(body.startDate ?? body.start_date ?? url.searchParams.get("startDate") ?? url.searchParams.get("start_date") ?? "").trim();
      const endDate = String(body.endDate ?? body.end_date ?? url.searchParams.get("endDate") ?? url.searchParams.get("end_date") ?? "").trim();

      if (!apartmentId || !startDate || !endDate) {
        return json({ error: "apartmentId, startDate, endDate required" }, 400);
      }

      // Attempt 1
      let resp = await smoobuFetch(req,
        `https://login.smoobu.com/api/apartments/${encodeURIComponent(apartmentId)}/rates?from=${encodeURIComponent(startDate)}&to=${encodeURIComponent(endDate)}`,
        { method: "GET" }
      );

      // If endpoint not supported in your account, fallback:
      if ((resp as Response).status === 200) return resp;

      return await smoobuFetch(req,
        `https://login.smoobu.com/api/rates?apartmentId=${encodeURIComponent(apartmentId)}&from=${encodeURIComponent(startDate)}&to=${encodeURIComponent(endDate)}`,
        { method: "GET" }
      );
    }

    // -------------------------
    // Update Rates (Auto-Pricing upload)
    // Supports action=update-rates or update_rates
    // Expects body: { apartments: [<id>], operations: [{ dates:[YYYY-MM-DD], daily_price:<number> }, ...] }
    if (action === "update-rates") {
      const payload = body ?? {};
      if (!payload || !payload.apartments || !payload.operations) {
        return jsonResponse({ error: "Missing apartments/operations" }, 400);
      }

      const res = await fetch("https://login.smoobu.com/api/rates", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Api-Key": apiKey
        },
        body: JSON.stringify(payload)
      });

      const data = await safeJson(res);
      return jsonResponse(data, res.status);
    }


    // -------------------------
    // Ticketmaster (optional)
    // -------------------------
    if (action === "ticketmaster") {
      const apiKey = Deno.env.get("TICKETMASTER_API_KEY");
      if (!apiKey) return json({ error: "Ticketmaster API key not configured" }, 501);

      const city = url.searchParams.get("city") || "";
      const countryCode = url.searchParams.get("countryCode") || "DE";
      const startDate = url.searchParams.get("startDate") || "";
      const endDate = url.searchParams.get("endDate") || "";
      const size = url.searchParams.get("size") || "50";

      const qs = new URLSearchParams({
        apikey: apiKey,
        locale: "de-de",
        size,
        countryCode,
      });
      if (city) qs.set("city", city);
      if (startDate) qs.set("startDateTime", `${startDate}T00:00:00Z`);
      if (endDate) qs.set("endDateTime", `${endDate}T23:59:59Z`);

      const endpoint = `https://app.ticketmaster.com/discovery/v2/events.json?${qs.toString()}`;
      const tmResp = await fetch(endpoint);
      const txt = await tmResp.text();
      let out: any = null;
      try { out = txt ? JSON.parse(txt) : null; } catch { out = txt; }

      if (!tmResp.ok) return json({ ok: false, status: tmResp.status, error: out }, tmResp.status);
      return json({ ok: true, status: tmResp.status, result: out }, 200);
    }

    return json({ error: "Invalid action", version: VERSION, receivedAction: action ?? null, method: req.method, url: req.url }, 400);
  } catch (e) {
    return json({ error: "Unhandled error", details: String(e?.message ?? e) }, 500);
  }
});
